Dim CurrentObj 
sub set_novCDCO(novCDCOObj) 
	set CurrentObj = Nothing 
	set CurrentObj = novCDCOObj 
end sub 
sub set_CDCOnothing() 
	set CurrentObj = Nothing 
end sub 
'namespace ()
                
'*****************************************************************************
' RRunner.rrx Script File
'
' Licensed Materials - Property of IBM
' “Restricted Materials of IBM”
' 5725-C15 5725-C69
'
' © Copyright IBM Corp. 1994, 2016 All Rights Reserved
'
' US Government Users Restricted Rights - Use, duplication or
' disclosure restricted by GSA ADP Schedule Contract with
' IBM Corp.
'
'*****************************************************************************

'(Declarations)

On Error Resume Next 

Dim gbRRX
gbRRX = True
Dim PicCharAr(10)
Dim FileMgr
Dim ImageCtrl
Dim oConn
Dim CCOCreator
Dim gbDebug
Dim gbInteractive
Dim gbInter
Dim g_Atmr
Dim g_Ftmr
Dim g_Rtmr
Dim g_ATottmr
Dim g_FTottmr
Dim g_RTottmr
Dim g_ABatchtmr
Dim g_FBatchtmr
Dim g_RBatchtmr
Dim nDefID
Dim conn
Dim oCurPage
Dim bAbort
Dim sVarName
Dim CCO
Dim bFail
Dim bOverride
Dim nReturnStatus
Dim arRules
Dim nCurRule
Dim arActions
Dim nCurAction
Dim nDefaultRtn
Dim nRectIndex
Dim dictExists
Dim dictTmp
Dim dictPreserve
Dim g_nRuleType
Dim g_InitObj
Dim g_bRulestats
Dim nTaskStatus
Dim g_LogInset
Dim bEnableUI
Dim bProcessChildren
Dim g_bAbortOnError
Dim g_aggrStat
Dim gbLoadedCCO
Dim g_sFPDBDSN
gbLoadedCCO=""
strBaseImageName=""
g_sFPDBDSN=""

Dim nFail
Dim nPass
Dim nOver
Dim nAbort
Dim nPreserve

nFail = 1
nPass = 0
nOver = 3
nAbort = -1

nPreserve = True
g_bRuleStats = False
bEnableUI = True
g_LogInset = 0
bAbort = False
g_bAbortOnError = False

'TaskStatus List
Const RetAbort 	= 0
Const RetFinished = 2
Const RetHold 	= 4
Const RetPending 	= 8

'DCO Constants
Const DCO_BATCH = 0
Const DCO_DOCUMENT = 1
Const DCO_PAGE = 2
Const DCO_FIELD = 3
Const DCO_CHARACTER = 4

Dim dictInitGlobal
Set dictInitGlobal = CreateObject("Scripting.dictionary")

Const nRtn_Over = 1
Const nRtn_Fail = 2

bOverride = True
nTaskStatus = RetFinished 

'ADODB Constants
Const adOpenForwardOnly = 0
Const adOpenKeyset = 1
Const adOpenDynamic = 2
Const adOpenStatic = 3

Const adLockReadOnly = 1
Const adLockPessimistic = 2
Const adLockOptimistic = 3

Const adUseClient = 3
Const adUseServer = 2

'Statistics Variables
Dim g_RRnDocDict
Dim g_RRnPagDict
Set g_RRnDocDict = CreateObject("Scripting.dictionary")
Set g_RRnPagDict = CreateObject("Scripting.dictionary")

'Elapsed Time counter
Dim g_eTime
g_eTime=0

'QA DATA
Dim sStateStack
sStateStack=""
Dim rr_xDom
Set rr_xDom = CreateObject("MSXML2.DOMDocument")
rr_xDom.Async=False  

'Global DCO Object Dictionary
Dim dictDCOGlobal
Set dictDCOGlobal = CreateObject("Scripting.dictionary")

'Create DCSmart Object
Dim g_DCSmart
Set g_DCSmart = CreateObject("dcSmart.SmartNav")

If IsAlive(g_DCSmart) then 
	WriteLog("Smartparameter Object created")
	g_DCSmart.DatacapRRDCO=DCO
	g_DCSmart.DatacapRRLog=DCLogX
	g_DCSmart.SetRRCurrentDCO(CurrentObj)
	g_DCSmart.DatacapRRBatchPilot=Pilot
	g_DCSmart.DatacapRRState=RRState
End if

Dim DCGlobalStrings
Set DCGlobalStrings = CreateObject("Datacap.Global.Strings")
If IsAlive(DCGlobalStrings) then WriteLog("Datacap Global Strings Object created")

Dim DCGlobalDates
Set DCGlobalDates = CreateObject("Datacap.Global.Dates")
If IsAlive(DCGlobalDates) then WriteLog("Datacap Global Dates Object created")

Dim DCGlobalCurrency
Set DCGlobalCurrency = CreateObject("Datacap.Global.Currency")
If IsAlive(DCGlobalCurrency) then WriteLog("Datacap Global Currency Object created")

Dim DCGlobalLocale
Set DCGlobalLocale = CreateObject("Datacap.Global.Locale")
If IsAlive(DCGlobalLocale) then WriteLog("Datacap Global Locale Object created")

Dim DCGlobalBidi
Set DCGlobalBidi = CreateObject("Datacap.Global.Bidi")
If IsAlive(DCGlobalBidi) then WriteLog("Datacap Global Bidi Object created")

Dim sOriginalLocaleID
sOriginalLocaleID = ""

'Note: 9.1.0.130 populated via RRX.cs
WriteLog("rrunner: loading file v. 9.1.0.130")
Call UpdateLocale()

'INIT RRS OBJECTS - RRX ONLY

Sub ErrorHandler(strmsg)
   'Nothing to do here
End sub

Sub InitObjects()

  On Error Resume Next

	Set FileMgr = CreateObject("Scripting.FileSystemObject")
  If IsAlive(FileMgr) then WriteLog("Global FileMgr Object created")
  
	Set ImageCtrl = CreateObject("DCIMAGE.DcimageCtrl.1")
  If IsAlive(ImageCtrl) then WriteLog("Global ImageCtrl Object created")
  
	Set oConn = CreateObject("ADODB.Connection")
	If IsAlive(oConn) then WriteLog("Global oConn Object created")
  
	Set CCOCreator=CreateObject("CCO._CCOCreator")
	If IsAlive(CCOCreator) then WriteLog("Global CCOCreator Object created")
	
	gbDebug = RRState.DebugMode
	gbInteractive = RRState.Interactive
	gbInter = RRState.Interactive

  Set CCO = Nothing
  Set CCO = CreateObject("CCO._CCOCollection")
  If IsAlive(CCO) then WriteLog("Global CCO Object created")

  'Log the batch xml
  Call Writelog("Pilot XML:" & vbcrlf & Pilot.ExportXML() & vbcrlf)
End sub

Call InitObjects()
  
Sub InitPage()
  'Find current parent page and load CCO if it has a cco file
  Dim oPage
  On Error Resume Next
  
    If IsAlive(CurrentObj) then ' ---- Added for Quattro compatibility to fix error described in SPR 23678 (update "7.6.41")
      Set oPage = CurrentObj
    
      While oPage.ObjectType<>2 and oPage.ObjectType>0
        Set oPage = oPage.Parent    
      Wend
    
      If oPage.ObjectType=0 then Exit Sub
    
      Call LoadCCO(oPage)

      Set oCurPage = Nothing
      Set oCurPage = oPage
    Else
      Call Writelog("CurrentObj is Nothing")     
    End if

End Sub
 
Sub LoadCCO(oPage)
  Dim sVar
  Dim strBaseImageName
  Dim bFound

  On Error Resume Next

  bFound=False
  sVar="DATAFILE"
        
  If oPage.FindVariable(sVar)<0 Then sVar="IMAGEFILE"
  If oPage.FindVariable(sVar)>=0 Then  
				
	strBaseImageName = Trim(Left(oPage.Variable(sVar), Len(oPage.Variable(sVar))-3) & "cco")
     
  'Check if CCO matches Loaded CCO
  If ucase(gbLoadedCCO)=ucase(strBaseImageName) and strBaseImageName<>"" then Exit Sub
    
    If IsAlive(DCLogX) Then
		WriteLog("Set DCLogX")
		CCOCreator.LogX = DCLogX ' requires debug version of CCOCreator
		If Err.Number <> 0 then WriteLog("Err " & Err.Description)
		If oPage.FindVariable("CCOFILE") >= 0 Then
			WriteLog("Set MaxWaitTime")
			CCOCreator.MaxWaitTime = 5000	' wait up to 5 seconds for CCO to exist
			If Err.Number <> 0 then WriteLog("Err " & Err.Description)
		End If
	End If
  
	If FileMgr.FileExists(strBaseImageName) Then
     If Not IsAlive(CCOCreator) then Set CCOCreator=CreateObject("CCO._CCOCreator")
     Set CCO=Nothing
     Set CCO=CCOCreator.Load(strBaseImageName)
	   If IsAlive(CCO) Then 'Added for Quattro compatibility SPR# 25101 update 7.6.46
			'Call Writelog("Loaded CCO 1:'" & strBaseImageName & "'" & ", count=" & CCO.Count)
			if (CCO.Count < 1) then WriteLog("Loaded empty CCO")
			bFound=True
			gbLoadedCCO=strBaseImageName
			Call CCO.SetCurrentPosition(1,1)
	Else
		Writelog ("Error: CCO object Is Nothing")
	End if
  End if
    
	  If TrapError("Getting Data File name for " & oPage.Id)=False Then
	  End If
       
  End if
    
  If bFound=False then  
	  'create empty cco for pages with no images or data 
	  Set CCO=Nothing
	  Set CCO=CreateObject("CCO._CCOCollection")
  End If
    
End Sub

'------ Initialize Timers on load ------
g_ATottmr=cdbl(0)
g_FTottmr=cdbl(0)
g_RTottmr=cdbl(0)
g_ABatchtmr=cdbl(0)
g_FBatchtmr=cdbl(0)
g_RBatchtmr=cdbl(0)

g_Atmr=cdbl(Timer)
g_Ftmr=cdbl(Timer)
g_Rtmr=cdbl(Timer)

Call InitPage()      

Sub InitDStudio()
  'Initialize the Pilot.ProjectPath() property for use in DStudio.
  'Must point to the DCO setup folder with Paths.ini as the target filename.
  Dim sPath
  Dim oDCOSetup
  
  On Error Resume Next
  
  If IsAlive(Pilot) Then
    If Pilot.ProjectPath="" then
      Set oDCOSetup = DCO.SetupObject()
      sPath=FileMgr.GetParentFolderName(oDCOSetup.Path)
      sProjPath=FileMgr.BuildPath(sPath,"Paths.ini")
      Pilot.ProjectPath=sProjPath
      Set oDCOSetup = Nothing
    End if
  End if
  
End Sub

Call InitDStudio()

'------ Initialize On Load -------
RRState.OnProcessStart="Call OnProcessStart()"
RRState.OnActionStart="Call OnActionStart()"
RRState.OnActionFailure="Call OnActionFailure()"
RRState.OnActionSuccess="Call OnActionSuccess()"
RRState.OnFunctionStart="g_Ftmr=cdbl(Timer)"
RRState.OnFunctionFailure="Call OnFunctionEnd()"
RRState.OnFunctionSuccess="Call OnFunctionEnd()"
RRState.OnRuleStart="Call OnRuleStart()"
RRState.OnRuleFailure="Call StatCounter():Call OnRuleEnd()"
RRState.OnRuleSuccess="Call StatCounter():Call OnRuleEnd()"
RRState.OnRuleSetStart="Call OnRuleSetStart()"
RRState.OnRuleSetEnd="Call OnRuleSetEnd()"
RRState.OnProcessEnd="Quit()"

 'Reset RRS Data Elements
  RRState.Pop("nTaskStatus")
  RRState.Data("ActionAbortLog")="False"
  RRState.Data("bOverride")="True"
  RRState.Data("bAbort")="False"
  RRState.Data("stats_nDocs")=cstr(0)
  RRState.Data("stats_nPages")=cstr(0)
  RRState.LogicResult=1
  

Sub OnProcessStart() 
  RRState.OnActionStart="Call OnActionStart()"
  RRState.OnActionFailure="Call OnActionFailure()"
  RRState.OnActionSuccess="Call OnActionSuccess()"
  RRState.OnFunctionStart="g_Ftmr=cdbl(Timer)"
  RRState.OnFunctionFailure="Call OnFunctionEnd()"
  RRState.OnFunctionSuccess="Call OnFunctionEnd()"
  RRState.OnRuleStart="Call OnRuleStart()"
  RRState.OnRuleFailure="Call StatCounter():Call OnRuleEnd()"
  RRState.OnRuleSuccess="Call StatCounter():Call OnRuleEnd()"
  RRState.OnRuleSetStart="Call OnRuleSetStart()"
  RRState.OnRuleSetEnd="Call OnRuleSetEnd()"
  RRState.OnProcessEnd="Quit()"
  
 'Reset RRS Data Elements
  RRState.Pop("nTaskStatus")
  RRState.Data("ActionAbortLog")="False"
  RRState.Data("bOverride")="True"
  RRState.Data("bAbort")="False"
  RRState.Data("stats_nDocs")=cstr(0)
  RRState.Data("stats_nPages")=cstr(0)
  RRState.LogicResult=1

End Sub

Sub OnActionStart() 
  On Error Resume Next

  'Enable Dynamic Locale
  Call UpdateLocale()
  'Initialize Action Timer
  g_Atmr=cdbl(Timer)
  
End Sub

Sub OnActionFailure() 
  On Error Resume Next
  
  'TEST
  Call QAStateData("False")
    
  Call OnActionEnd()
  
  
  
End Sub

Sub OnActionSuccess() 
  On Error Resume Next
  
  'TEST
  Call QAStateData("True")
    
  Call OnActionEnd()
   
  
End Sub

Sub OnActionEnd() 
  
    Dim sTime
    Dim bBypassAbort
    
    sTime=cdbl(Timer)-g_Atmr    
    g_Atmr=cdbl(0)
    g_ATottmr=g_ATottmr+sTime
       
    'Check for unhandled action error
    Call ErrorHandler("RRunner OnActionEnd() has caught an error from the previous action.")
    
    If (bAbort=True or RRState.Data("bAbort")="True") and  RRState.LogicResult<>-1 then
        If RRState.Data("ActionAbortLog")<>"True" then  
          Writelog("ATTENTION: This action has set the Task to Abort at the COMPLETION of the Ruleset. (bAbort=True)")
        Else
          Writelog("ATTENTION: An action run earlier in this ruleset has set the Task to Abort at the completion of the Ruleset. (bAbort=True)")
        End if
        'flag to only log the message once
        RRState.Data("ActionAbortLog")="True" 
    End if

    If cstr(nTaskStatus)=cstr(0) or cstr(RRState.Data("nTaskStatus"))=cstr(RetAbort) then
        RRState.LogicResult=-1
    End if

    If sTime<>0 then Writelog("Action esec='" & FormatNumber(sTime,5,True) & "'")


End Sub

Sub OnFunctionEnd() 
  Dim sTime
  
  sTime=cdbl(Timer)-cdbl(g_Ftmr)    
  g_Ftmr=cdbl(0)
  g_FTottmr=g_FTottmr+sTime
  If sTime<>cdbl(0) then Writelog("Function esec='" & FormatNumber(sTime,5,True) & "'")
    
  sStateStack=""
 
  
End Sub

Sub OnRuleStart() 
   'Initialize Rule Timer
   g_Rtmr=cdbl(Timer)
   Call InitPage()
   
   If IsAlive(g_DCSmart) then g_DCSmart.DatacapRRCurrentDCO = CurrentObj
   

End Sub

Sub OnRuleSetStart() 
Dim sValue

On Error Resume Next        
        
If IsAlive(g_DCSmart) then 
	g_DCSmart.DatacapRRState=RRState
	g_DCSmart.DatacapRRLog=DCLogX
	g_DCSmart.DatacapRRBatchPilot=Pilot
	g_DCSmart.DatacapRRDCO=DCO
	g_DCSmart.DatacapRRCurrentDCO = CurrentObj
End if

sValue = Pilot.ExportXML()

Call Writelog("OnRuleSetStart Pilot XML:" & vbcrlf & sValue & vbcrlf)


End Sub

Sub OnRuleSetEnd() 
If bAbort=True then nTaskStatus=retAbort

  'Sync Abort variables
  If RRState.Data("bAbort")="True" Then nTaskStatus=cstr(0) 
  If cstr(nTaskStatus)=cstr(0) then RRState.Data("bAbort")="True"
  If cstr(nTaskStatus)<>cstr(RetFinished) And cstr(RRState.Data("nTaskStatus"))<>cstr(RetFinished) then RRState.Data("nTaskStatus")=nTaskStatus

  'Setup Data to always have bOverrride value of True or False
  If RRState.Data("bOverride")<>"False" then RRState.Data("bOverride")="True"
  
  'Reset loaded CCO & ImageCtrl  
  gbLoadedCCO=""
  ImageCtrl.Filename="" 
 
  Call writelog("RuleSet finished with TaskStatus '" & cstr(nTaskStatus) & "'")

  'write RRState xml to log file
  Call Writelog("Total Ruleset Action   esec:'" & FormatNumber(g_ATottmr,5,True) & "'")
  Call Writelog("Total Ruleset Function esec:'" & FormatNumber(g_FTottmr,5,True) & "'")
  Call Writelog("Total Ruleset Rule     esec:'" & FormatNumber(g_RTottmr,5,True) & "'")
  
  g_ABatchtmr=g_ABatchtmr+cdbl(g_ATottmr)
  g_FBatchtmr=g_FBatchtmr+cdbl(g_FTottmr)
  g_RBatchtmr=g_RBatchtmr+cdbl(g_RTottmr)
  
  If g_ABatchtmr>g_ATottmr then Call Writelog("Total Profile Action   esec:'" & FormatNumber(g_ABatchtmr,5,True) & "'")
  If g_FBatchtmr>g_FTottmr then Call Writelog("Total Profile Function esec:'" & FormatNumber(g_FBatchtmr,5,True) & "'")
  If g_RBatchtmr>g_RTottmr then Call Writelog("Total Profile Rule     esec:'" & FormatNumber(g_RBatchtmr,5,True) & "'")
  
  g_ATottmr=cdbl(0)
  g_FTottmr=cdbl(0)
  g_RTottmr=cdbl(0)

  Dim sValue
  sValue = Pilot.ExportXML()

  Call Writelog("OnRuleSetEnd Pilot XML:" & vbcrlf & sValue & vbcrlf)

  If IsAlive(g_DCSmart) then g_DCSmart.DatacapRRCleanupTime = true


End Sub

Sub OnRuleEnd() 
  'Only used in RRX environment
   nDefaultRtn = nRtn_Over 

    Call RestoreLocale() ' Make sure we are back to the original locale

    Dim sTime
    sTime=cdbl(Timer)-g_Rtmr    
    g_Rtmr=cdbl(0)
    g_RTottmr=g_RTottmr+sTime
        
    Call Writelog("OVERRIDEABLE:" & RRState.Data("bOverride"))
    If cstr(nTaskStatus)=cstr(0) then 
        RRState.LogicResult=-1
    End if
    If sTime<>cdbl(0) then Writelog("Rule esec='" & FormatNumber(sTime,5,True) & "'")
  
  If IsAlive(g_DCSmart) then g_DCSmart.DatacapRRCurrentDCO = Nothing
  

End Sub

Sub OnRuleFailure() 
   'Only used in RRX environment
    On Error Resume Next

    Call Writelog("OnRuleFailure...") 

        'Set CurrentObj status :'CurrentObj.Status=nFail
        Call rrFailNodes(CurrentObj)

        'Set Override/Non-Override flag
        If nDefaultRtn = nRtn_Fail Then
            RRState.Data("bOverride")="False"
            Call Writelog("OVERRIDEABLE:" & RRState.Data("bOverride"))
        End If

End Sub

Sub rrFailNodes(oNode) 
	Dim oParent
    
    On Error Resume Next
    
    'Only used in RRX environment
    If oNode is Nothing then Exit Sub
        
    'Set Node to Fail status
    If oNode.Status=nPass then 
      oNode.Status=nFail
      Call Writelog("rr Setting " & oNode.ID & " to Status '" & nFail & "'")
    Else
      Call Writelog("rr " & oNode.ID & " is not Status '" & nPass & "' ,will not set to Status '" & nFail & "'" )
    End if
    
    'Check for Parent Node to set status
    If oNode.Variable("victim")<>"yes" then
        If oNode.ObjectType<>DCO_BATCH then
      
            Set oParent=oNode.Parent()
            If oParent.Status<>nFail then 
                Call rrFailNodes(oParent)
            End if

            Set oParent=Nothing 
        End if
    Else
        Call Writelog(oNode.ID & " is Victim (Start Node)")
    End if
    

End Sub

Sub StatCounter() 
	 Dim ObjID  
   Dim ObjType
   Dim PagID
   Dim DocID
   Dim oParent
   Dim etime
   
   DocID = ""
   PagID = ""
   ObjID = Trim(CurrentObj.ID)
   If len(ObjID)=0 then Exit Sub
     
   Select Case CurrentObj.ObjectType
		Case 1
      'Document
      DocID=ObjID
      
		Case 2
      'Page
      PagID=ObjID

  End Select

  'Aggregate Statistic
  If g_aggrStat= True Then
    Set oParent=CurrentObj
    While (DocID="" or PagID="") AND oParent.ObjectType>0
      If oParent.ObjectType=2 then PagID=oParent.ID
      If oParent.ObjectType=1 then DocID=oParent.ID
      Set oParent=oParent.Parent
    Wend
  End if
  
  If PagID<>"" then
	  If Not g_RRnPagDict.Exists(PagID) then
      Call g_RRnPagDict.Add(PagID,1)
    End if
  End if
  
  If DocID<>"" then
    If Not g_RRnDocDict.Exists(DocID) Then
      Call g_RRnDocDict.Add(DocID,1)
    End if
  End if
  
  Writelog("DocCount " & g_RRnDocDict.Count & ",  PageCount " & g_RRnPagDict.Count)

  RRState.Data("stats_nDocs")=cstr(g_RRnDocDict.Count)
  RRState.Data("stats_nPages")=cstr(g_RRnPagDict.Count)
  

End Sub

Function DetermineLocale()
		
  ' Determine the locale that should be used.  First check hr_locale for the current object.  
  ' If not set, the current thread locale is returned
  ' The locale Name is returned, not the LCID
	
  On Error Resume Next

  Dim sLocale
  Dim sCurLocale
  
  'Find the locale variable, if it is set.  This value will override the current thread's locale.  Returns as 'Name'
  sLocale = CurrentObj.Variable("hr_locale")
  sLocale = trim(sLocale)
	  
  If len(sLocale)>0 and (Not sLocale="-1") then
     Writelog("hr_locale = " & sLocale)
     DetermineLocale = sLocale
     Exit Function
  End if
  
  sCurLocale = Trim(cStr(GetLocale()))  ' Returns as LCID
  DetermineLocale = DCGlobalLocale.Name(sCurLocale)
  WriteLog("Current Locale: '" & sCurLocale & " (" & DetermineLocale & ")' " & DCGlobalLocale.Description(sCurLocale))   
  Exit Function

End Function
		
Function RestoreLocale()
		
  ' Set the locale back to the original locale.
	
  On Error Resume Next

  if (sOriginalLocaleID = "") Then
    Exit Function
  End if

  'writelog("Restoring locale: " & sOriginalLocaleID)
  SetLocale(sOriginalLocaleID) ' Reset to the original locale.
  sOriginalLocaleID = ""

  Exit Function

End Function
		
Sub UpdateLocale() 
  On Error Resume Next
  
  Dim sLocaleName
  Dim sLocaleLCID
  Dim sCurLocale
  Dim sCurLocaleName
    
  sLocaleName = DetermineLocale    ' Returns Name  
  sLocaleLCID = Cstr(DCGlobalLocale.Lcid(sLocaleName))
  sCurLocale  = Cstr(GetLocale())  ' Returns LCID
  sCurLocaleName = DCGlobalLocale.Name(sCurLocale)
  
  if (sOriginalLocaleID = "") Then
    sOriginalLocaleID = sCurLocale
    'writelog("Saving original locale: " & sOriginalLocaleID)
  End if
  
  'Check current locale - exit if matched
  If sCurLocale = sLocaleLCID then
    ' WriteLog("rrunner: No change to RRS Locale '" & sCurLocale & " (" & sCurLocaleName & ")' " & DCGlobalLocale.Description(sCurLocale)) 
    Exit Sub
  End if
  
  If err.number<>0 then 
    Writelog("Error in UpdateLocale A. Err:" & Err.Number & " Description:" & Err.Description)
    Err.Clear
  End if
    
  'Update Script to new locale
  SetLocale(sLocaleLCID)
  WriteLog("rrunner: Changed RRS Locale from '" & sCurLocale  & " (" & sCurLocaleName & ")' " & "' to '" & sLocaleLCID & " (" & sLocaleName & ")' " & DCGlobalLocale.Description(sLocaleLCID)) 
  
  If err.number<>0 then 
    Writelog("Error in UpdateLocale B. Err:" & Err.Number & " Description:" & Err.Description)
    WriteLog("Error after attempting: rrunner: Existing RRS Locale '" & GetLocale() & "'. Setting Locale to '" & sLocaleLCID & "'.") 
    Err.Clear
  Else
    Writelog("Dynamic Locale: locale set to: '" & sLocaleName & "'")
  End if
  
  'Update action variables
  RRState.Data("hr_locale")=sLocaleName
  If err.number<>0 then 
    Writelog("Error in UpdateLocale C. Err:" & Err.Number & " Description:" & Err.Description)
    Err.Clear
  End if
  
  Pilot.TaskVar("hr_locale")=sLocaleName
  If err.number<>0 then 
    Writelog("Error in UpdateLocale D. Err:" & Err.Number & " Description:" & Err.Description)
    Err.Clear
  End if
   
  'WriteLog("Node Locale '" & GetLocale() & "'")

End Sub

Function QAStateData(result)
		
    Dim sFunct
    Dim sAction  
    Dim oNode
    Dim sNode
    
    On error resume next
      
    If cstr(RRState.Data("QA"))<>"1" then Exit Function 
  
	  sXML = RRState.XML

		If rr_xDom.LoadXML(sXML) Then
      
			'Get Function id
      sNode="//func"
			Set oNode=rr_xDom.SelectSingleNode(sNode)
		  If IsAlive(oNode) Then
				sFunct = oNode.GetAttribute("id")
        RRState.Data("LastFunctionName")=sFunct
			End If
		   					
      'Get Action id
      sNode="//func/a"
			Set oNode=rr_xDom.SelectSingleNode(sNode)
		  If IsAlive(oNode) Then
				sAction = oNode.GetAttribute("id")
        RRState.Data("LastActionName")=sAction
			End If                                                 
                                
      RRState.Data("LastActionResult")=result                        
                                
      If cstr(RRState.Data("QAS"))="1" then
        RRState.Data("QAStackLog")=RRState.Data("QAStackLog") & sAction & " --> " & result & vbcrlf
      End if
                                
		Else
			Writelog("QAStateData failed to load XML")
		End If

		Set oNode=Nothing
    
    writelog(RRState.xml)
    

End Function
		
Sub Log(sMessage) 
	bOut = Writelog(sMessage)

End Sub

Sub SetEnableUI(bOnOff) 
	bEnableUI = bOnOff

End Sub

Function dummy(returnWhat)
		
		dummy = returnWhat
		
End Function
		
Function CMyLng(sValue)
		
	CMylng=0
	If Trim(CStr(sValue))="" Then Exit Function
	If Not IsNumeric(sValue) Then Exit Function
	CMyLng = CLng(sValue)

End Function
		
Sub SetDefID(defaultID) 
	nDefID = defaultID

End Sub

Sub SetRR_ID(defaultID,oPage,oCCO) 
	nDefID = defaultID
	If IsObject(oPage) Then Set oCurPage=oPage
	If IsObject(oCCO) Then Set CCO=oCCO

End Sub

Function bPreserve()
		
	bPreserve = True
	If dictPreserve.Exists(g_nRuleType) Then
		bPreserve = CBool(dictPreserve(g_nRuleType))
		'Writelog("Preserve Status :" & CStr(bPreserve))
	End If	

End Function
		
Function GetTaskStatus()
		
	If bAbort = True Then nTaskStatus = RetAbort
	GetTaskStatus = nTaskStatus

End Function
		
Function GetAbort()
		
	GetAbort = False
	If bAbort = True Then GetAbort = True
	If nTaskStatus = RetAbort Then GetAbort= True

End Function
		
Function SetCurRule(nIndex)
		
	nCurRule = nIndex	

End Function
		
Function GetOverride()
		
	GetOverride=bOverride

End Function
		
Function GetReturnStatus()
		
	GetReturnStatus=nReturnStatus

End Function
		
Sub InitReturnStatus(Stat) 
	nReturnStatus = Stat
	bOverride=True

End Sub

Sub SetRuleStatistics(bEnabled) 
	g_bRuleStats = bEnabled

End Sub

Function GetDocCount()
		
	GetDocCount = g_RRnDocDict.Count 

End Function
		
Function GetPagCount()
		
	GetPagCount = g_RRnPagDict.Count

End Function
		
Function GetDataArray(sSQL)
		
	Dim arRes
	Dim rs
		
  On Error Resume Next  
    
  Const adOpenStatic = 3   
  Const adUseClient = 3
  Const adLockOptimistic = 3 
  Const adLockBatchOptimistic = 4 
    
		GetDataArray=arRes
	
		If InitFPDB=False Then Exit Function
	  	
    'Remove leading & trailing spaces
    sSQL=Trim(sSQL)
  
    If Instr(Ucase(conn.Provider),ucase("OraOLEDB"))>0 or Instr(Ucase(conn.Provider),Ucase("MSDAORA"))>0 Then
       'Remove "invalid" character semicolon if last character for Oracle DB's
       If instrrev(sSQL,";")=len(sSQL) Then
            sSQL=Trim(left(sSQL,len(sSQL)-1))
       End If
    End If	

		If InStr(sSQL, "SELECT")=1 Then
      Set rs = CreateObject("ADODB.RecordSet")
      rs.CursorLocation = adUseClient
      rs.Open sSQL, conn, adOpenStatic, adLockBatchOptimistic
      Set rs.ActiveConnection = Nothing
		Else
      conn.Execute(sSQL)
      Exit Function
		End If
		
		If DBErrTrap(conn, "GetDataArray1") Then
			If IsAlive(rs) then rs.Close()
			Set rs=Nothing
			Exit Function
		End If

		nCount=0

		If rs.EOF Then
			'Writelog(Space(4) & "No rows selected.")
			rs.Close()
			Set rs=Nothing
			Exit Function
		End If
	
		nCount=0
		
		rs.MoveFirst()

		While Not rs.EOF
			nCount=nCount+1
			rs.MoveNext()
		Wend

		rs.MoveFirst
		nCount=nCount-1
		nFields=rs.Fields.Count-1
		ReDim arRes(nCount, nFields)

		For i=0 To nCount
			For j=0 To nFields
				arRes(i,j)=rs.Fields(j).Value
				If DBErrTrap(conn,"GetDataArray2") Then
					rs.Close()
					Set rs=Nothing 
					Exit Function
				End If
			Next
			rs.MoveNext
		Next

		rs.Close()
		Set rs=Nothing
		
	GetDataArray=arRes
	

End Function
		
Function ModifySQLByDBType(oConnect,byval sSQL)
		
		
	On Error Resume Next
	Dim provider
	provider = UCase(oConnect.Provider)
	
    'Remove leading & trailing spaces
    sSQL=Trim(sSQL)
  
    If Instr(provider,"ORAOLEDB")>0 or Instr(provider,"MSDAORA")>0 Then
       'For Oracle DBs remove 'invalid' character (semicolon) if last character
       If instrrev(sSQL,";")=len(sSQL) Then
            sSQL=Trim(left(sSQL,len(sSQL)-1))
       End If
    End If
    
    ModifySQLByDBType = sSQL
	

End Function
		
Function Init(sDSN,bInteractive,bDeb,sVar)
		
	Dim sConnStr
	Init=False
	bInter=bInteractive
	bDebug=bDeb	
			
	Init=False
	
	On Error Resume Next
	
  If Not gbRRX then
	Call Writelog("rrunner.dcs " & rr_Version)
	End if
	
	nTaskStatus = RetFinished
	sVarName=sVar
	Set conn=CreateObject("ADODB.Connection")
	
  g_sFPDBDSN=sDSN
  
	If Not gbRRX then

    If InitFPDB=False Then
        Call Writelog("Init Connection Error:" & Err.Description)
        Writelog("No fingerprint/RulesDB connection Established. ABORTING!!")
        nTaskStatus = RetAbort
	      Err.Clear
      	Exit Function
	  End If
  
  End if 
	  
  If Not IsAlive(CCOCreator) then 
    Set CCOCreator=CreateObject("CCO._CCOCreator")
  End if
  
	If IsNull(CCOCreator) Or TrapError("CCO Creator Failure") Then
		nTaskStatus = RetAbort
		Writelog("CCOCreator Failure in INIT function")	
		Exit Function
	End If
	
  'Initialize Statistic Vars
	g_RRnDocDict.RemoveAll
	g_RRnPagDict.RemoveAll
  g_aggrStat=True
  
	Set dictTmp=CreateObject("Scripting.Dictionary")
	Set dictExists=CreateObject("Scripting.Dictionary")
	Set dictPreserve=CreateObject("Scripting.Dictionary")
	
	'Progress Counter
	g_InitObj = ""
	g_LogInset = 0

	If IsObject(dictInitGlobal) Then 
		Dim fCall, aFCall
		aFcall = dictInitGlobal.Keys
		For Each fCall in aFCall
			Dim sCParam
			sCParam = dictInitGlobal.Item(FCall)
			Dim sEval
			sEval = CStr(fCall)' & "(" & sCParam & ")") 
		
			Dim ehwhat
			ehwhat = CBool(Eval(sEval))
				
		Next
		Call dictInitGlobal.RemoveAll	
	Else
		Call Writelog("No dictInitGlobal Object Found")
	End If
	Init=True
	

End Function
		
Function InitFPDB()
		
  ' returns False if a connection could not be established. 
  ' returns True if connection is already open or opening the connection was successful

  On Error Resume Next
  
  Dim sConnstr
  
  InitFPDB = True
 
  If Not IsAlive(conn) then
    Writelog("connection object failure")
    InitFPDB=False
    Exit function
  End if
 
  If conn.State=1 then Exit Function
    
  'Attempt fips decryption 
  bRes = RRState.SecureCallAA("-9071026645268915568","2991680700059384086",g_sFPDBDSN,sConnstr)   
  If bRes=False Then Writelog("Value not Decrypted.")
        
  Call Writelog("Opening Fingerprint DB")
  conn.Open(FormatADOConn(sConnstr))
	  
  If conn.State<>1 Or TrapError("Open Connection") Then 
    InitFPDB=False
    Writelog("WARNING: Fingerprint Database connection could not be established!")
  Else
    Writelog("Fingerprint/Rules Database connection established.")
	End If
    
  
End Function
		
Function GlobalInit()
		
    Dim loP
    Dim loCurrObj
    Dim strDSN
    Dim sWrkKey
    Dim sAppKey
    Dim sGenKey
    Dim slocale
    
    strDSN=""
  
    On Error Resume Next
  
    'Check for locale setting in DCO then AppSvc
    Call AppSvc_getlocale()     
	      
    set loP = CurrentObj

    'Check for AppSvc Fingerprint connection string value
    If IsAlive(RRState.Application) then
	    Writelog("Retrieving Fingerprint DB Connection string from Application Service")
			
		  'look for workflow name 
		  sWrkKey="*/dco_" & RRState.WorkflowName & "/fingerprintconn:cs"
		  Writelog("Looking for AppSvc Workflow Name key: '" & sWrkKey & "'")
		  Call RRState.Application.vbGetKeyValue(sWrkKey,0,False,strDSN)
		  If len(strDSN)>0 then
		      Writelog("AppSvc Workflow fingerprintconn found.")
              GlobalInit = Init(strDSN, gbInter, gbDebug, "TemplateID")
              Exit Function
          Else
              Writelog("No AppSvc Workflow Name key found.")
          End If
		
		  'look for app name 
		  sAppKey="*/dco_" & RRState.ApplicationName & "/fingerprintconn:cs"
		  Writelog("Looking for AppSvc Application Name key: '" & sAppKey & "'")
		  Call RRState.Application.vbGetKeyValue(sAppKey,0,False,strDSN)
		  If len(strDSN)>0 then
			  Writelog("AppSvc Application name fingerprintconn.")
              GlobalInit = Init(strDSN, gbInter, gbDebug, "TemplateID")
              Exit Function
          Else
              Writelog("No AppSvc Application Name key found.")
          End If
		
		  'look for general name
		  sGenKey="*/fingerprintconn:cs"
		  Writelog("Looking for AppSvc General key: '" & sGenKey & "'")
	      Call RRState.Application.vbGetKeyValue(sGenKey,0,False,strDSN)
	      If len(strDSN)>0 then
              GlobalInit = Init(strDSN, gbInter, gbDebug, "TemplateID")
              Exit Function
          Else
              Writelog("No AppSvc General key found.")
          End If
           
	End if

	While IsObject(loP) And Not(loP Is Nothing)
		set loCurrObj = Nothing
		set loCurrObj = loP
		set loP = Nothing
		set loP = loCurrObj.Parent()
	Wend

	If IsObject(loCurrObj) And Not(loCurrObj Is Nothing) then
		strDSN = loCurrObj.Variable("FingerprintConn")
        If len(trim(strDSN))>0 then
    		    WriteLog("Fingerprint Database Connection String Found.")
        Else
            Writelog("No Fingerprint Database Connection String was found in the Setup DCO.")
	    End if
        GlobalInit = Init(strDSN, gbInter, gbDebug, "TemplateID")
	End if


End Function
		
Function AppSvc_getlocale()
		

     On Error Resume Next

     Dim slocale

    'Check for locale setting in DCO then AppSvc
    slocale = DCO.Variable("hr_locale")
    
    If slocale = "" or slocale="-1" and IsAlive(RRState.Application) then
     
      Writelog("Retrieving locale setting from Application Service")
			
		  'look for workflow name 
		  sWrkKey="*/dco_" & RRState.WorkflowName & "/locale"
		  Writelog("Looking for AppSvc Workflow Name key: '" & sWrkKey & "'")
		  Call RRState.Application.vbGetKeyValue(sWrkKey,0,False,slocale)
		  If len(slocale)>0 then 
        DCO.Variable("hr_locale")=slocale
        Writelog("Batch locale set to '" & slocale & "' from Application Service.") 
        Exit Function
		  End if
      slocale=""
      
		  'look for app name 
		  sAppKey="*/dco_" & RRState.ApplicationName & "/locale"
		  Writelog("Looking for AppSvc Application Name key: '" & sAppKey & "'")
		  Call RRState.Application.vbGetKeyValue(sAppKey,0,False,slocale)
		  If len(slocale)>0 then 
        DCO.Variable("hr_locale")=slocale
        Writelog("Batch locale set to '" & slocale & "' from Application Service.") 
        Exit Function
		  End if
		  slocale=""
      
		  'look for general name
		  sGenKey="*/locale"
		  Writelog("Looking for AppSvc General key: '" & sGenKey & "'")
	    Call RRState.Application.vbGetKeyValue(sGenKey,0,False,slocale)
	    If len(slocale)>0 then 
        DCO.Variable("hr_locale")=slocale
        Writelog("Batch locale set to '" & slocale & "' from Application Service.") 
        Exit Function
		  End if          
                  
      Writelog("No locale setting found in the Application Service.") 

  End if
    
  
End Function
		GlobalInit()
Sub InsertFailStats(nTemp,nAction,sBatch,sImage,sResult) 
	Dim sSQL

	If Not g_bRuleStats = True Then Exit Sub

	If sBatch="" Or sImage="" Or sResult="" Then
		Writelog("Unable to insert statistic. Some fields empty.")
		Exit Sub
	End If
	
	On Error Resume Next

  If InitFPDB=False then Exit Sub

	If CLng(nTemp) < CLng(555) Then nTemp = CLng(555)	

	sSQL="INSERT INTO RULESTATS (ST_TEMPLATEID, ST_ACTIONID, ST_BATCHID, ST_IMAGE, ST_RESULT) VALUES (" &_
			CStr(nTemp) & ", " & CStr(nAction) & ", '" & sBatch & "', '" & sImage & "', '" & sResult & "');"
	
	Writelog(Space(5) & "Executing : " & sSQL)
	conn.Execute(sSQL)
	TrapError("InsertFailStats")

End Sub

Sub WriteDataFile(DcoObj) 
	Dim sDataFile
	Dim sExt
	Dim nTime
	nTime=timer	
		
	On Error Resume Next	
		
	sDataFile = ""
	exit sub
	If DcoObj.ObjectType=3 and DcoObj.Variable("DATAFILE")<>"" Then
		  If DcoObj.Write(DcoObj.Variable("DATAFILE")) = False then
        Writelog("Unable to Write file:'" & DcoObj.Variable("DATAFILE") & "' for object '" & DcoObj.ID & "'. ABORTING TASK. ")
        nTaskStatus = RetAbort
	    End if
  End if 
	
	If DcoObj.ObjectType <> 2 Then Exit Sub
	If DcoObj.NumOfChildren=0 Then Exit Sub
	
	sDataFile = DcoObj.Variable("DATAFILE")
	
	If sDataFile = "" Then
		sDataFile = DcoObj.Variable("IMAGEFILE")	
		sDataFile =	left(sDataFile,len(sDataFile)-3) & "xml"
		DcoObj.Variable("DATAFILE")=sDataFile	
	End if  
	  
	If DcoObj.Write(sDataFile)=False Then
		 Writelog("Unable to Write file:'" & sDataFile & "' for object '" & DcoObj.ID & "'. ABORTING TASK ")
     nTaskStatus = RetAbort
	End if
	Writelog("Write File eTime:" & cstr(Timer-ntime))

End Sub

Function Quit()
		
	
  bReturn=true
    
	If bReturn=False then 
		Call AbortBatch()
		RRState.Data("nTaskStatus")=RetAbort
		Call Writelog("ERROR Writing '" & Pilot.Dcofile & "' Data files. Aborting.")
		Call Writelog("DCO Last Error:'" & DCO.GetLastError() & "'.")
	End if

  On Error Resume Next
  
  If IsAlive(conn)Then
		If conn.State=1 Then conn.Close()
	End If
  Set conn=Nothing
  
  If IsAlive(oConn)Then
		If oConn.State=1 Then oConn.Close()
	End If
  Set oConn=Nothing
  
  If IsAlive(g_DCSmart) then g_DCSmart.DatacapRRCleanupTime = true
  Set g_DCSmart = Nothing
  
	Set CCOCreator=Nothing
  Set CCO=Nothing
  
  Call dictExits.RemoveAll()
	Set dictExists=Nothing
  
  Call dictTmp.RemoveAll()
	Set dictTmp=Nothing
	  
  Call dictPreserve.RemoveAll()
  Set dictPreserve=Nothing
    
  Call dictInitGlobal.RemoveAll()
  Set dictInitGlobal=Nothing
  
  Call g_RRnDocDict.RemoveAll()
  Set g_RRnDocDict=Nothing
  
  Call dictDCOGlobal.RemoveAll()
  Set dictDCOGlobal=Nothing
  
  Set g_DCSmart = Nothing

  Set DCGlobalStrings = Nothing
  Set DCGlobalDates = Nothing
  Set DCGlobalCurrency = Nothing
  Set DCGlobalLocale = Nothing
  
  Set FileMgr = Nothing
  Set ImageCtrl = Nothing
  Set oConn = Nothing
  Set oFsys = Nothing
  Set rr_xDom = Nothing  

  'Clear errors from cleanup
  Err.Clear
  

End Function
		
Function TrapError(sFrom)
		
	TrapError=False
	
	If Err.number=0 Then
		Exit Function
	End If

	sMessage="*** Error #'" & CStr(Err.Number) & "' (" & Err.Description & ") in sub/function:" & sFrom 
	Call Writelog(sMessage)
	
	Err.Clear
	TrapError=True
	


End Function
		
Function DBErrTrap(ConnectionObj,sDescription)
		
	Dim sStr
	Dim oErr
	Dim sNumString	

	DBErrTrap = False
	
	If ConnectionObj.Errors.Count > 0 Then
		sStr = vbCrLf
		sNumString = ""

		For Each oErr In ConnectionObj.Errors
		
      Select Case cstr(oErr.Number)
      
        Case "0","265929","-2147217887" 
			
				Call WriteLog("DB Connection WARNING! Err number: " & oErr.Number & "  Desc: " & oErr.Description)
				ConnectionObj.Errors.Clear
				DBErrTrap = False
				Exit Function
			  
        Case Else	
				  sNumString = sNumString & oErr.Number & Space(1)
        
			End Select
		
			Call WriteLog("*------------------- DATABASE ERROR ------------------")			
			Call WriteLog("* " & sDescription)
			Call WriteLog("* Description: " & oErr.Description)
	 		Call WriteLog("*  Numeric ID: " & CStr(oErr.Number)) 
			Call WriteLog("* Data Source: " & oErr.Source)
	   		Call WriteLog("*-------------------- DATABASE ERROR -----------------")
   		 	
	 	Next 'Err  	
	 	  		
 		DBErrTrap = True
 		ConnectionObj.Errors.Clear
   		If ConnectionObj.Errors.Count <> 0 Then Call Writelog("Error Obj Not Cleared") 
		sDescription = sNumString
 	End If	

End Function
		
'================================== Action Utility Functions =================

Function WriteLog(byval txtmsg)
		

		If IsAlive(DCLogX) Then	Call DCLogX.Write(Space(1) & txtmsg)


End Function
		
Function DeBugLog(byval txtmsg)
		

	If Not bDebug Then Exit Function

		If IsAlive(DCLogX) Then	Call DCLogX.Write(Space(1) & txtmsg)


End Function
		
Function Convert4Xml(sTextMsg)
		
	Convert4Xml = Replace(sTextMsg    ,"&", "&amp;") 
	Convert4Xml = Replace(Convert4Xml ,"<", "&lt;") 
	Convert4Xml = Replace(Convert4Xml ,">", "&gt;") 	 
	Convert4Xml = Replace(Convert4Xml ,"'", "&apos;")
	Convert4Xml = Replace(Convert4Xml ,Chrw(34),"&quot;")

End Function
		
Function DCOMessage(txtmsg)
		

	On Error Resume next
		
	If Not CurrentObj.AddVariable("MESSAGE",txtmsg) Then 
		CurrentObj.Variable("MESSAGE") = txtmsg
	End If


End Function
		
Function lenT(value)
		
      lenT=-1
      
      if IsAlive(DCGlobalStrings) then
        LenT=clng(DCGlobalStrings.LengthInTextElements(value))
      End if
      
      
End Function
		
Function InstrT(searchin,searchfor,startindex,compareoption)
		
      InstrT=-1 
      
      startindex=cint(startindex)
      compareoption=cint(compareoption)
      
      if IsAlive(DCGlobalStrings) then
        InstrT=clng(DCGlobalStrings.InstrTextElements(searchin, searchfor, startindex, compareoption))
      End if
      
      
End Function
		
Function rr_EscapeRegExProtectedChars(FindStr)
		
        
  'Check for and protect against RegEx reserved characters 
       
  On Error Resume Next

  FindStr = Replace(FindStr,"*","\*")
  FindStr = Replace(FindStr,"\","\\")
  FindStr = Replace(FindStr,"^","\^")
  FindStr = Replace(FindStr,"$","\$")
  FindStr = Replace(FindStr,"+","\+")
  FindStr = Replace(FindStr,"?","\?")
  FindStr = Replace(FindStr,".","\.")
  FindStr = Replace(FindStr,"[","\[")
  FindStr = Replace(FindStr,"]","\]")
  FindStr = Replace(FindStr,"(","\(")
  FindStr = Replace(FindStr,")","\)")
  FindStr = Replace(FindStr,"|","\|")
  FindStr = Replace(FindStr,"{","\{")
  FindStr = Replace(FindStr,"}","\}")
  FindStr = Replace(FindStr,",","\,")
  FindStr = Replace(FindStr,"-","\-")

  rr_EscapeRegExProtectedChars=FindStr


End Function
		
Function MessageID(Message,Identifier)
		

	On Error Resume next
		
	CurrentObj.Variable("MESSAGE") = Message
	
  Identifier = Trim(Identifier)
  If len(Identifier)>0 then
  		  CurrentObj.Variable("MessageID") = Identifier
	End if
  

End Function
		
Function MessageIDParameter(Value,ValueType,Index)
		

	On Error Resume next
	
  MessageIDParameter=True
  
  Dim sParamName
  Dim sParamType
  sParamText = "MessageParamText_" & cstr(Index)
  sParamType = "MessageParamType_" & cstr(Index)
  
  Dim ResolvedValue
  Dim RX
  Dim sMessage
  Dim bTypes
  bTypes=False
  
  'permitted 'Type' values:
  Dim Types
  Types = Array("job", "task", "shortcut", "field", "workflow", "appname", "pagetype", "doctype", "text", "variable")    
  
  'check Type is a an allowed value 
  For t = 0 to (ubound(Types)-1)
    If lcase(ValueType)=Types(t) Then
      bTypes=True
      Exit For
    End if
  Next 't
  
  If (BTypes=False) Then
    Writelog("Type '" & ValueType & "' is not a member of the allowed types:'" & Join(Types,",") & ".")
    Exit Function
  End if
  
  'check for duplicate Parameter index     
  If CurrentObj.FindVariable(sParamText)>=0 or CurrentObj.FindVariable(sParamType)>=0 Then
    Writelog("Reusing Parameter index. Existing value '" & CurrentObj.Variable(sParamText) & "' and type '" &  CurrentObj.Variable(sParamType) & "' will be replaced.")
  end if
  
  'save MessageParamType variable & value to DCO node
  CurrentObj.Variable(sParamText) = Value
  CurrentObj.Variable(sParamType) = ValueType
       
  'resolve values as allowed; eg SmartParameter
  Writelog("Resolving Value '" & Value & "'...")
  ResolvedValue = MetaWord(Value)
  If Len(ResolvedValue) = 0 Then ResolvedValue = Value 
  
  'Perform Message Substitution
  sMessage = CurrentObj.Variable("MESSAGE")
  If Len(sMessage)=0 then
    Writelog("The 'MESSAGE' variable is empty. Exiting Action.")
    Exit Function
  Else
    Writelog("Current 'MESSAGE' value:'" & sMessage & "'.")
  End if
  
  Dim sPattern
  sPattern = "{" & cstr(Index) & "}"
  
  writelog("pattern:'" &  sPattern & "'.")
  'sResult = DCGlobalStrings.RemoveReplace(sMessage,cint(nStartIndex-1),sInsertString,cint(nMaxMatches), CurrentObj)
	sNewMessage = Replace(sMessage, sPattern, ResolvedValue)
  writelog("replace:" & sNewMessage)  
    
  If Trim(sMessage) <> Trim(sNewMessage) then
    sMessage = sNewMessage
    Writelog("Substitution successful. New 'MESSAGE' value: '" & sMessage & "'.")
  Else
    Writelog("A Substitution was not successfull. Please check your settings if a substitution was supposed to occur.")
	End if
  
  'save MessageParamText variable & value to DCO node
  CurrentObj.Variable("MESSAGE") = sMessage
  CurrentObj.Variable(sParamText) = ResolvedValue
  

End Function
		
Function GetFieldValue()
		

	If Not IsObject(CurrentObj) Or CurrentObj Is Nothing Then Exit Function
	
	If CurrentObj.ObjectType<3 Then 
		GetFieldValue = CurrentObj.Variable("Text")
	Else
		GetFieldValue = CurrentObj.Text
	End if


End Function
		
Function GetFieldConf()
		

	If Not IsObject(CurrentObj) Or CurrentObj Is Nothing Then Exit Function
		 
	GetFieldConf = CurrentObj.ConfidenceString
	

End Function
		
Function SetFieldValue(NewValue)
		

		Exit Function
	

End Function
		
Function GetProjectName()
		
	If strProjectName = "" Then
		strPath = Trim(Pilot.ProjectPath)
		strExt = FileMgr.GetExtensionName(strPath)
		If strPath <> "" Then
			strProjectName = Left(strPath,Len(strPath)-Len(strExt)-1)
		End If
	End If
	GetProjectName = strProjectName

End Function
		
Sub ErrorHandler(DescString) 
	Dim eStr

	If Err.Number <> 0 Then		
		Writelog(" ")
		Writelog(String(60,"*"))
		Writelog("*       ERROR! --> '" & DescString & "' ")
		Writelog("* DESCRIPTION: " & Err.Description)
		Writelog("*  NUMERIC ID: " & CStr(Err.Number))
		Writelog("*      SOURCE: " & Err.Source)
		Writelog(String(60,"*"))
		Writelog(" ")
		
		If g_bAbortOnError=True Then nTaskStatus = RetAbort
		
		Err.Clear
	End If


End Sub

Function ShowRect(leftX,topY,rightX,bottomY)
		
	If nRectIndex>-1 Then
		Call ImageCtrl.EraseRect(nRectIndex)
	End If

	nRectIndex = ImageCtrl.DrawRect(leftX-2,topY-2,rightX+2,bottomY+2,3,RGB(0,0,255),RGB(255,0,0),"")

	'refreshes the image
	ImageCtrl.Zoom = ImageCtrl.Zoom 
	
	ShowRect = True

End Function
		
Function PreserveStatus(bInter,bDebug,bOFF)
		
	nPreserve=bOFF

  	If Not dictPreserve.Exists(g_nRuleType) Then 
  		Call dictPreserve.Add(g_nRuleType,nPreserve)
  	Else
  		dictPreserve(g_nRuleType) = nPreserve
  	End If
  
	PreserveStatus = nPreserve

End Function
		
Function ObjectCount(Obj,ObjType)
		
	Dim nCount
	Dim I
	Dim sObj
	
	ObjectCount=cint(0)
	
	Set sObj=Obj
	If sObj.ObjectType = ObjType Then
		ObjectCount=cint(1)
	Else
		If sObj.ObjectType < ObjType Then
			nCount=sObj.NumOfChildren
			For I=0 To nCount-1
				ObjectCount=ObjectCount + Cint(ObjectCount(sObj.GetChild(I),ObjType))
			Next
		End If
	End If
	Set sObj = Nothing

End Function
		
Function IsAlive(vbObj)
		
	IsAlive=False
	If IsEmpty(vbObj) Then
		Exit Function
	End If
	If IsObject(vbObj)=False Then
		Exit Function
	End If
	If vbObj Is Nothing Then
		Exit Function
	End If
	IsAlive=True

End Function
		
Function ProcessChildrenFirst(bInter,bDebug)
		
	bGoUp = True
	ProcessChildrenFirst = True

End Function
		
Function FormatADOConn(strParam)
		
	Dim sConnStr
	Dim sProvider
	Dim sDSN
	Dim sCatalog
	Dim sUID
	Dim sPWD
	Dim sDBNTA
	Dim aConnParse
	Dim i
	Dim RX
	Dim sTEST

	On Error Resume Next
	
	FormatADOConn = strParam
				
	'Find Connection Sections via Keywords	
	Set RX = CreateObject("VBScript.RegExp")
	RX.IgnoreCase = True
	RX.Global = True
	
	aConnParse = Split(strParam,";")
	
	For i = 1 to (ubound(aConnParse)+1)
		  RX.Pattern=" *PROVIDER *="
		  If RX.Test(aConnParse(i-1)) then
			  sProvider = Trim(RX.replace(aConnParse(i-1),""))
		  End if

      RX.Pattern = " *CATALOG *="
		  If RX.Test(aConnParse(i-1)) then
			  sCatalog = trim(RX.replace(aConnParse(i-1),""))
		  End if

      RX.Pattern = " *DBNTA *="
		  If RX.Test(aConnParse(i-1)) then
			  sDBNTA = trim(RX.replace(aConnParse(i-1),""))
		  End if

		  RX.Pattern = " *DSN *="
		  If rx.Test(aConnParse(i-1)) then
			  sDSN = trim(RX.replace(aConnParse(i-1),""))
		  End if
              
      RX.Pattern = " *UID *="
		  If rx.Test(aConnParse(i-1)) then
			  sUID = trim(RX.replace(aConnParse(i-1),""))
		  End if
         
      RX.Pattern = " *PWD *="
		  If rx.Test(aConnParse(i-1)) then
			  sPWD = trim(RX.replace(aConnParse(i-1),""))
		  End if
  		
      RX.Pattern = " *SQLTEST *="
      If rx.Test(aConnParse(i-1)) then
		    sTEST = RX.replace(aConnParse(i-1),"")
		  End if
	Next 'i

    'Remove SQLTEST entry	
    RX.Pattern = " *SQLTEST *=" & sTEST & ";"
    strParam = trim(RX.replace(strParam,""))
       
    Set RX = Nothing

    If Ucase(Trim(sTEST))="YES" or Ucase(Trim(sTEST))="1" then
        writelog("Passthrough FormatADOConn string:'" & strParam & "' ")    
	      FormatADOConn = strParam  
        Exit Function
    End if

	Select Case Ucase(sProvider)
		Case "MSSQL"
			sConnStr = "Provider=SQLOLEDB;Server=" & sDSN & ";Database=" & sCatalog & ";"
			If Ucase(sDBNTA) = "YES" Then
				sConnStr = sConnStr & "Integrated Security=sspi;"
				sPWD=""
				sUID=""
            Else
                sConnStr = sConnStr & "UID=" & sUID & ";PWD=" & sPWD & ";"
			End if
		Case "MSACCESS"
			sConnStr = "Provider=Microsoft.Jet.OLEDB.4.0;Data Source=" & sDSN & ";"
		Case "ORACLE"
			sConnStr = "Provider=OraOLEDB.Oracle;Data Source=" & sDSN & ";" 
			sConnStr = sConnStr & "User Id=" & sUID & ";"
			sConnStr = sConnStr & "Password=" & sPWD & ";"
			
		Case "MSORACLE"
			sConnStr = "Provider=MSDAORA;Data Source=" & sDSN & ";"
			sConnStr = sConnStr & "User Id=" & sUID & ";"
			sConnStr = sConnStr & "Password=" & sPWD & ";"

		Case "ODBCMSSQL","ODBCMSACCESS","ODBCORACLE","ODBCMSORACLE"
			sConnStr = "DSN=" & sDSN & ";UID=" & sUID & ";PWD=" & sPWD & ";"
		Case ""
			If len(sDSN)=0 and ubound(aConnParse)=0 then sConnStr = "DSN=" & strParam & ";"
		Case Else
			'Other provider string!
			sConnStr = strParam
	End Select
	
	FormatADOConn = sConnstr


End Function
		
Function FormatTMConn(strParam)
		
	Dim sConnStr
	Dim sProvider
	Dim sDSN
	Dim sDataSource
	Dim sDatabase
	Dim sCatalog
	Dim sUID
	Dim sPWD
	Dim sDBNTA
	Dim aConnParse
	Dim i
	Dim RX


	On Error Resume Next

	FormatTMConn = strParam
				
	'Find Connection Sections via Keywords	
	Set RX = CreateObject("VBScript.RegExp")
	RX.IgnoreCase = True
	RX.Global = True
	
	strParam = strParam & ";"
	aConnParse = Split(strParam,";")
	
	For i = 1 to ubound(aConnParse)
  
		RX.Pattern = " *DATASOURCE *="
    If RX.Test(aConnParse(i-1)) then  
			sDataSource = trim(RX.replace(aConnParse(i-1),""))		
		End if	

		RX.Pattern = " *DATABASE *="
    If RX.Test(aConnParse(i-1)) then
      sDatabase = trim(RX.replace(aConnParse(i-1),""))
		End if
    
		RX.Pattern = " *PROVIDER *="
    If RX.Test(aConnParse(i-1)) then  
			sProvider = Trim(RX.replace(aConnParse(i-1),""))
		End if
		
		RX.Pattern = " *CATALOG *="
    If RX.Test(aConnParse(i-1)) then  
			sCatalog = trim(RX.replace(aConnParse(i-1),""))
		End if
    
		RX.Pattern = " *DBNTA *="
    If RX.Test(aConnParse(i-1)) then  
			sDBNTA = trim(RX.replace(aConnParse(i-1),""))
		End if
    
		RX.Pattern = " *DSN *="
    If RX.Test(aConnParse(i-1)) then  
			sDSN = trim(RX.replace(aConnParse(i-1),""))
		End if
    
		RX.Pattern = " *UID *="
    If RX.Test(aConnParse(i-1)) then  
			sUID = trim(RX.replace(aConnParse(i-1),""))
		End if
    
		RX.Pattern = " *PWD *="
    If RX.Test(aConnParse(i-1)) then  
			sPWD = trim(RX.replace(aConnParse(i-1),""))
		End if
	Next 'i

	Set RX = Nothing

	Select Case UCase(sProvider)
		Case "SQLOLEDB"
			sConnStr = "PROVIDER=MSSQL;DSN=" & sDSN & ";CATALOG=" & sDatabase & ";"
			If instr(ucase(strParam),"SSPI")>0  Then
				sConnStr=sConnStr & "DBNTA=yes;"
			Else
				sConnStr=sConnStr & ";UID=" & sUID & ";PWD=" & sPWD & ";"
			End if
		Case "MICROSOFT.JET.OLEDB.4.0"
			sConnStr = "PROVIDER=MSACCESS;DSN=" & sDataSource & ";UID=" & sUID & ";PWD=" & sPWD & ";"
		Case "ORAOLEDB.ORACLE"
			sConnStr = "PROVIDER=ORACLE;DSN=" & sDataSource & ";UID=" & sUID & ";PWD=" & sPWD & ";"
		Case "MSDAORA"
			sConnStr = "PROVIDER=MSORACLE;DSN=" & sDataSource & ";UID=" & sUID & ";PWD=" & sPWD & ";"			
		'Case "ODBCMSSQL","ODBCMSACCESS","ODBCORACLE","ODBCMSORACLE"
		'	sConnStr = "DSN=" & sDSN & ";UID=" & sUID & ";PWD=" & sPWD & ";"
		Case ""
			If len(sDSN)=0 and ubound(aConnParse)=0 then 
				sConnStr = "PROVIDER=ODBCMSACCESS;DSN=" & strParam & ";"
			Else
				sConnStr = "PROVIDER=ODBCMSACCESS;DSN=" & strParam & ";UID=" & sUID & ";PWD=" & sPWD & ";"
			End if
		Case Else
			'Other provider string!
			sConnStr = strParam
			Writelog("String may not be a valid aTM connection string.")
	End Select
	
	'writelog("FormatTMConn string:'" & sConnstr & "' ")
	FormatTMConn =  sConnstr	
	

End Function
		
Function CheckAnchor(bInter,bDebug,strParam)
		
	Dim oAnc
	CheckAnchor = False
	
	Set oAnc = CurrentObj.FindChild(strParam)

	If oAnc Is Nothing Then
		WriteLog("Anchor field (" & strParam & ") not found!")
		Exit Function
	Else
		rtn = oAnc.GetPosition(A,B,C,D)

		If Not rtn Or (A+B+C+D) <= 0 Then
			Writelog("Anchor field (" & strParam & ") position not set!")
			Exit Function
		End If
		CheckAnchor = True
	End If

	Set oAnc = Nothing

End Function
		
Function CheckDICT(DCOobject)
		
	Dim FieldValue
	
  If DCOObject.Objecttype<DCO_Field then
    CheckDICT = DCOObject.Variable("Text")
  Else
    CheckDICT = DCOobject.Text
	End if
	
	FieldValue = u_DCODict(DCOobject,1)
  
  If len(FieldValue)>0 then CheckDICT=FieldValue


End Function
		
Function u_DCODict(DCONode,DictType)
		
	
  On Error Resume Next

  If Not IsAlive(g_DCSmart) then
     Writelog("Datacap Smart Parameter object not found")
	   Exit function
  End if 
  
  u_DCODict=g_DCSmart.u_DCODict(DCONode,DictType)
  

End Function
		
Sub RRCopyChars(oSource,oDest,nStart,nLen) 
  ' Merges Characters from oSource to oDest (DCO Field) nodes
  ' Includes character position and confidence information
  ' NOTE: WILL APPEND TO EXISTING CHARACTERS IN oDEST node!!
	
	Dim x,y
	Dim cObj_S
	Dim cObj_D
	Dim nFields
	Dim Cleft ,Ctop ,Cright ,Cbottom
	Dim Fleft ,Ftop ,Fright ,Fbottom
	Dim SPos, aPosition
		
	If oSource is Nothing then Exit Sub
	If oDest is Nothing then Exit Sub
	If Not Isnumeric(nstart) then Exit Sub
	If Not Isnumeric(nLen) then Exit Sub

	Fleft = ""
	Ftop = ""
	Fright=""
	Fbottom=""
	
	On Error Resume Next
	
	'Character Index begins after any child fields
	nFields = oSource.NumOfChildren - len(oSource.Text)

	nStart=nStart+nFields

	For x = nStart to (nLen+nStart-1)
		Set cObj_S = oSource.GetChild(x-1)
		Set cObj_D = oDest.AddChild(4,"",-1)
		
		If Not cObj_S is Nothing and Not cObj_D is Nothing then 
					
			cObj_D.CharValue(0)= cObj_S.CharValue(0)
			cObj_D.CharConfidence(0) = cObj_S.CharConfidence(0)

			SPos=cObj_S.Variable("Position")
			cObj_D.Variable("Position")=SPos	
			
			aPosition = Split(SPos, ",")
			For i=0 To UBound(aPosition)
				aPosition(i)=CLng(aPosition(i))
			Next

			If Ubound(aPosition)>=3 Then
				Cleft=aPosition(0)
				Ctop=aPosition(1)
				Cright=aPosition(2)
				Cbottom=aPosition(3)
			End if
				
			If Not(Cleft=0 and Ctop=0 and Cright=0 and Cbottom=0) Then 			
						
				If Fleft="" then FLeft=Clng(Cleft)
				If Clng(Cleft)<Fleft then FLeft=Clng(Cleft)
				If Ftop="" then Ftop=Clng(Ctop)
				If Clng(Ctop)<Ftop then Ftop=Clng(Ctop)
				If Fright="" then Fright=Clng(Cright)
				If Clng(Cright)>Fright then Fright=Clng(Cright)
				If Fbottom="" then Fbottom=Clng(Cbottom)
				If Clng(Cbottom)>Fbottom then Fbottom=Clng(Cbottom)
	
			End if
		End if
	Next 'x

	If Fleft="" then FLeft=Clng(0)		
	If Ftop="" then Ftop=Clng(0)
	If Fright="" then Fright=Clng(0)
	If Fbottom="" then Fbottom=Clng(0)

	oDest.Variable("Position") = cstr(Fleft) & "," & cstr(Ftop) & "," & cstr(Fright) & "," & cstr(Fbottom)
	Set cObj_S = Nothing
	Set cObj_D = Nothing
	

End Sub

Sub RRCopyPos(oSource,oDest,nStart,nLen) 
' Merges Positions from oSource to oDest (DCO Field) nodes
' NOTE: WILL APPEND TO EXISTING POSITION IN oDEST node!!	
	
	Dim x,y
	Dim cObj_S
	Dim cObj_D
	Dim nFields
	Dim Cleft ,Ctop ,Cright ,Cbottom
	Dim Fleft ,Ftop ,Fright ,Fbottom
	Dim FPosition
		
	If oSource is Nothing then Exit Sub
	If oDest is Nothing then Exit Sub
	If Not Isnumeric(nstart) then Exit Sub
	If Not Isnumeric(nEnd) then Exit Sub

	Fleft = ""
	Ftop = ""
	Fright=""
	Fbottom=""

	'Character Index begins after any child fields
	nFields = oSource.NumOfChildren - len(oSource.Text)

	'Find Current Position Info
	FPosition = oDest.Variable("Position")
	If FPosition = "0,0,0,0" then FPosition = ""
	aPosition = Split(FPosition, ",")
	For i=0 To UBound(aPosition)
		aPosition(i)=CLng(aPosition(i))
	Next

	If Ubound(aPosition)>=3 Then
		Fleft=aPosition(0)
		Ftop=aPosition(1)
		Fright=aPosition(2)
		Fbottom=aPosition(3)
	End if
	
	nStart=nStart+nFields
	
	For x = nStart to (nLen+nStart-1)
		Set cObj_S = oSource.GetChild(x-1)
				
		If Not cObj_S is Nothing then 
							
			SPos=cObj_S.Variable("Position")
						
			aPosition = Split(SPos, ",")
			For i=0 To UBound(aPosition)
				aPosition(i)=CLng(aPosition(i))
			Next

			If Ubound(aPosition)>=3 Then
				Cleft=aPosition(0)
				Ctop=aPosition(1)
				Cright=aPosition(2)
				Cbottom=aPosition(3)
			End if
			
			If Not(Cleft=0 and Ctop=0 and Cright=0 and Cbottom=0) Then 			
						
				If Fleft="" then FLeft=Clng(Cleft)
				If Clng(Cleft)<Fleft then FLeft=Clng(Cleft)
				If Ftop="" then Ftop=Clng(Ctop)
				If Clng(Ctop)<Ftop then Ftop=Clng(Ctop)
				If Fright="" then Fright=Clng(Cright)
				If Clng(Cright)>Fright then Fright=Clng(Cright)
				If Fbottom="" then Fbottom=Clng(Cbottom)
				If Clng(Cbottom)>Fbottom then Fbottom=Clng(Cbottom)
	
			End if
		End if
	Next 'x

	If Fleft="" then FLeft=Clng(0)		
	If Ftop="" then Ftop=Clng(0)
	If Fright="" then Fright=Clng(0)
	If Fbottom="" then Fbottom=Clng(0)
				
	oDest.Variable("Position") = cstr(Fleft) & "," & cstr(Ftop) & "," & cstr(Fright) & "," & cstr(Fbottom)
	Set cObj_S = Nothing
	

End Sub

Sub RRCopyImage(oSource,oTarget) 
	
' Ensures that the target field's child fields will retain the correct IMAGEFILE properties 
' when overwriting the target with data from a page other than its original.
	
	
	Dim nChildren
	Dim oChild	
		
	If oTarget.Variable("Position")="0,0,0,0" then oTarget.Variable("Position")=oSource.Variable("Position")
	If oTarget.Variable("IMAGEFILE")<>oSource.Variable("IMAGEFILE") Then
				
		'Update Child Fields with correct IMAGEFILE Variable. Must be performed before updating parent field, or 
		'child will reflect same ImageFile value as Target field. Only update child if child is same value as 
		'parent because child may have different ImageFile as parent.
				
		nChildren = oTarget.NumOfChildren - Len(oTarget.Text)
		For n = 1 to nChildren
			Set oChild = oTarget.GetChild(n-1)
			If Not(oChild is Nothing) Then
				If oChild.Variable("IMAGEFILE")=oTarget.Variable("IMAGEFILE") Then
					oChild.Variable("IMAGEFILE")=oTarget.Variable("IMAGEFILE")
					If len(Trim(oTarget.Variable("IMAGEHEIGHT")))<>"" then oChild.Variable("IMAGEHEIGHT")=oTarget.Variable("IMAGEHEIGHT")
				End if
			End if
		Next 'oChild
		Set oChild=Nothing
		
		oTarget.Variable("IMAGEFILE")=oSource.Variable("IMAGEFILE")
		If len(trim(oSource.Variable("IMAGEHEIGHT")))<>"" Then oTarget.Variable("IMAGEHEIGHT")=oSource.Variable("IMAGEHEIGHT")
	End if
	

End Sub

' DCO NAVIGATION

Function RReturnNamedComponent(byVal sFindObjID)
		
' Finds First Object matching ID by first searching children of 
' the calling object. If the calling object is a field the search will 
' check through each level in the current page back to the parent page.
' If the calling object is a page, the function will check back to the 
' parent document.
' Sets the ObjectType backwards search limit.

	Dim oNode	
	Dim iNum
	Dim rNode
	Dim iType
	Dim VarId
	Dim aObjID	
	
	
	On Error Resume Next
	
	
	iType = 2

	Set RReturnNamedComponent = Nothing
	Set oNode = CurrentObj

	If Not IsObject(oNode) Then Exit Function
	
	'If the calling object is a page, set the backlimit to the document.
	If oNode.ObjectType = 2 Then iType = 1
		
	'Check for & strip out variable name in sFindObjID argument. 
	'Flag is the Decimal '.' character (period).
		VarID = DCOFindVar(sFindObjID)
    If len(VarID)>0 then
        ObjID = replace(sFindObjID,"."&VarID,"")
    Else
        ObjID = sFindObjID
    End if
			
	'Check Each node Level Back to Parent Page	 
	While oNode.ObjectType >= iType
				 
		If oNode.Type = ObjId Then
			Set RReturnNamedComponent = oNode
			Set oNode = Nothing
			Exit Function
		End if	
			
		Set rNode = rr_SearchChildren(oNode, ObjID)

		If Not(rNode Is Nothing) Then 
			Set RReturnnamedcomponent = rNode
			Set rNode = Nothing
			Set oNode = Nothing	
			Exit Function
		End If

		Set oNode = oNode.Parent()			
		If Not IsObject(oNode) Then 
			Set oNode = Nothing
			Exit Function
		End if

	Wend

	Set rNode = Nothing
	Set oNode = Nothing
		

End Function
		
Function RReturnNamedValue(byVal sFindObjID)
		
	Dim oNode
	Dim iNum
	Dim rtnObj
	Dim iType
	Dim VarId
	Dim aObjID	
	
	On Error Resume Next
	
	Set oNode = Nothing
			
	'Check for variable in sFindObjID argument. Flag is the Decimal '.' character (period).
	VarID = DCOFindVar(sFindObjID)
		
	Set oNode = RReturnNamedComponent(sFindObjID)	
		
	If Not(oNode Is Nothing) Then 
		If Len(VarID)=0 then
			RReturnNamedValue = CheckDICT(oNode)
		Else
			RReturnNamedValue = oNode.Variable(VarID)
		End if
	End If

	Set oNode = Nothing
			

End Function
		
Function rr_SearchChildren(oDCO,byVal ObjID)
		
	Dim i
	Dim oDCOChild
		
	Set rr_SearchChildren = Nothing

	For i = 1 To (oDCO.NumOfchildren-Len(oDCO.Text))
		Set oDCOChild = oDCO.GetChild(i-1)
			
		If IsObject(oDCOChild) Then
			If oDCOChild.Type = ObjID Then
				Set rr_SearchChildren = oDCOChild
				Exit Function			
			End If
				
			If Len(oDCOChild.Text) <> oDCOChild.NumOfChildren Then 
				Set rr_SearchChildren = rr_SearchChildren(oDCOChild, ObjID)								
			End If

			If Not IsObject(rr_SearchChildren) Then Exit Function
		End If
	Next 'i


End Function
		
'New META UTILITY FUNCTIONS:

Function DCONav(sFindNode)
		
'Utility Function Returns DCO object based on Metacharacter string
'Special Characters:
'   a) ..\	navigate back 1 node (parent node)
'   b) .	value following period is a variable name - ignored in this function
'   c) \	next node (child)
'	d) @B	Root Batch Node
'	e) @D Root Document Node
'	f) @P	Root Page Node
'	g) @F	Root Field Node

	On Error Resume Next	
  
  If Not IsAlive(g_DCSmart) then
     Writelog("Datacap Smart Parameter object not found")
	   Exit function
  End if 

  Set DCONav=g_DCSmart.DCONav(sFindNode)	
		

End Function
		
Function DCOFindVar(byVal sFindObjID)
		

    On Error Resume Next
	
    If Not IsAlive(g_DCSmart) then
       Writelog("Datacap Smart Parameter object not found")
	     Exit function
    End if 
    
	  DCOFindVar=g_DCSmart.DCOFindVar(sFindObjID)
   	    

End Function
		
Function DCONavGetValue(byVal sFindObjID)
		
	On Error Resume Next
	  
  If Not IsAlive(g_DCSmart) then
     Writelog("Datacap Smart Parameter object not found")
	   Exit function
  End if 
  
	DCONavGetValue=g_DCSmart.DCONavGetValue(sFindObjID)
  			

End Function
		
Function DCONavSetValue(byVal sFindObjID,byVal sNewValue)
		
	On Error Resume Next
	
  If Not IsAlive(g_DCSmart) then
     Writelog("Datacap Smart Parameter object not found")
	   Exit function
  End if 

	DCONavSetValue=g_DCSmart.DCONavSetValue(sFindObjID,sNewValue)
			

End Function
		
Function MetaWord(sArgument)
		
		
    On Error Resume Next

   If Not IsAlive(g_DCSmart) then
     Writelog("Datacap Smart Parameter object not found")
	   Exit function
   End if 
  
   MetaWord=g_DCSmart.MetaWord(sArgument)
	  

End Function
		
Function DCONavType()
		

	On Error Resume Next

  If Not IsAlive(g_DCSmart) then
     Writelog("Datacap Smart Parameter object not found")
	   Exit function
  End if 

  DCONavType=g_DCSmart.DCONavType()
   		

End Function
		
'END DCO NAVIGATION

Function Status_Preserve_ON(bInter, bDebug) 
   
    RRState.OnRuleFailure="Call StatCounter():Call OnRuleEnd()"
    RRState.OnRuleSuccess="Call StatCounter():Call OnRuleEnd()"  
    RRState.OnRulesetStart="Call OnRuleSetStart()"

	Status_Preserve_ON = True

End Function

Function Status_Preserve_OFF(bInter, bDebug) 

    RRState.OnRuleStart="Call OnRuleStart():If CurrentObj.Status=nFail then CurrentObj.Status=nPass:CurrentObj.DeleteVariable(""MESSAGE""):nDefaultRtn = nRtn_Over"
    RRState.OnRuleSuccess="Call StatCounter():Call OnRuleEnd()" 
    RRState.OnRuleFailure="Call StatCounter():Call OnRuleFailure():Call OnRuleEnd()"
    RRState.OnRuleSetStart="Call OnRuleSetStart():RRState.OnRuleFailure="""":RRState.OnRuleStart=""Call OnRuleStart()"""
  
	Status_Preserve_OFF = True
	Writelog("Initializing Calling Object to status " & nPass)
	CurrentObj.Status = nPass
  CurrentObj.DeleteVariable("MESSAGE")	

End Function

Function DebugMode_ON(bInter, bDebug) 
  bDebug = True
	DebugLog("DebugMode ON")
	DebugMode_ON = True

End Function

Function DebugMode_OFF(bInter, bDebug) 
	Debuglog("DebugMode OFF")
	bDebug = False
	DebugMode_OFF = True

End Function

Function CheckAllIntegrity(bInter, bDebug) 
	Dim LastChecked
	Dim rtn

	CheckAllIntegrity = True
	
	rtn = DCO.CheckIntegrity(LastChecked)
	
	If rtn <> 0 Then
		If Not LastChecked Is Nothing Then
			WriteLog("CheckIntegrity returned : " & rtn & vbCrLf & Space(5) & "ID of last checked: " & LastChecked.ID) 
		End If
		CheckAllIntegrity = False
	End If

End Function

Function CheckDocCount(bInter, bDebug) 
	Dim nD
	Dim nDD
	Dim ED
	Dim aD
	Dim vD		
			
	nD = Trim(Pilot.ExpectedDocs)
	If nD="" or Not(isnumeric(nD)) then nD=0
	
	ED = Trim(DCO.Variable("ED"))
	If ED="" or Not(isnumeric(ED)) then ED=0
		
	If cint(nD)<=cint(1) and cint(ED)>0 then
		Writelog("DCO variable ED value found. Setting Pilot.ExpectedDocs to " & cstr(ED))
		nD = ED		
		Pilot.ExpectedDocs = clng(nD)
	End if

	aD = Trim(Pilot.AdjustedDocs)
	If aD="" or Not(isnumeric(aD)) then aD=0
		
	vD = Trim(DCO.Variable("AD"))
	If vD="" or Not(isnumeric(vD)) then vD=0

	If cint(aD)=cint(0) and cint(vD)>0 then
		Writelog("DCO variable AD value found. Setting Pilot.AdjustedDocs to " & cstr(vD))
		aD = vD		
		Pilot.AdjustedDocs = clng(aD)
	End if

	WriteLog("Expected documents:" & nD & ".")
	If aD>0 then 
		WriteLog("Adjusted documents:" & aD & ".")
		nD=aD
	End if 
	 
	nDD = ObjectCount(DCO, 1)

	WriteLog("Found " & cstr(nDD) & " documents")

	If cint(nDD) <> cint(nD) Then 
		WriteLog("Expected documents count does not match actual documents count!")
		CheckDocCount = False
	Else
		CheckDocCount = True
	End If


End Function

Function CheckPageCount(bInter, bDebug) 
	Dim nP
	Dim nPP
	Dim aP
	Dim vP
		
	nP = Trim(Pilot.ExpectedPages)
	If nP="" or Not(isnumeric(nP)) then nP=0
	
	nP = Trim(DCO.Variable("EP"))
	If nP="" or Not(isnumeric(nP)) then nP=0

	If cint(nP)=cint(0) and Len(EP)>0 then
		Writelog("DCO variable EP value found. Setting Pilot.ExpectedDocs to " & cstr(EP))
		nP = EP
		Pilot.ExpectedPages = clng(nP)
	End if

	aP = Trim(Pilot.AdjustedPages)
	If aP="" or Not(isnumeric(aP)) then aP=0
		
	vP = Trim(DCO.Variable("AP"))
	If vP="" or Not(isnumeric(vP)) then vP=0

	If cint(aP)=cint(0) and Len(vP)>0 then
		Writelog("DCO variable AP value found. Setting Pilot.AdjustedPages to " & cstr(vP))
		aP = vP		
		Pilot.AdjustedPages = clng(aP)
	End if

	WriteLog("Expected Pages:" & nP & ".")
	If aP>0 then 
		WriteLog("Adjusted pages:" & aP & ".")
		nP=aP
	End if 
	 
	nPP = ObjectCount(DCO, 2)

	WriteLog("Found " & cstr(nPP) & " pages")

	If cint(nPP) <> cint(nP) Then 
		WriteLog("Expected pages count does not match actual pages count!")
		CheckPageCount = False
	Else
		CheckPageCount = True
	End If

End Function

Function Task_RaiseCondition(bInter, bDebug, strParam) 
' Strparam is a CSV value
' 1) is the childindex
' 2) is the Condition to set the child to.			
	
	Dim aStrparam
	Dim nChildIndex
	Dim nConditionIndex

	Task_RaiseCondition= False

	aStrParam = Split(strParam & ",",",")
	nChildIndex = aStrParam(0)	
	nConditionIndex = aStrParam(1)

	If Not IsNumeric(nChildIndex) Then Exit Function
	If Not IsNumeric(nConditionIndex) Then Exit Function

	nConditionIndex = CLng(nConditionIndex)
	nChildIndex= CLng(nChildIndex)

	Pilot.ChildCondition(nChildIndex) = nConditionIndex

	Task_RaiseCondition= True

End Function

Function Task_NumberOfSplits(bInter, bDebug, nNumOfSplits) 
	Task_NumberOfSplits= False
	If Not IsNumeric(nNumOfSplits) Then
		Writelog("NumOfSplits Value is not Numeric.")
		Exit Function
	End If
	pilot.ChildrenQuantity=(CLng(nNumOfSplits))
	Writelog("Setting Task Number Of Splits to : " & nNumOfSplits)
	Task_NumberOfSplits= True

End Function

Function SetTaskStatus(bInter, bDebug, StrParam)  
 'use global variable nTaskStatus to send status to RuleRunner
 Const RetAbort = 0
 Const RetFinished = 2
 Const RetPending = 8
 Const RetHold = 4
   if(isNumeric(StrParam)) then
      nTaskStatus = cint(StrParam)
        RRState.Data("nTaskStatus")=StrParam
      Writelog("Set status of task to " & StrParam)
      SetTaskStatus = true
   else
     Writelog("Action's parameter is not numeric")
     SetTaskStatus = false 
   end if

End Function

Function SkipChildren(bInter, bDebug) 
	
    RRState.SkipChildren=True
	SkipChildren = True
	bprocesschildren = False

End Function

Function SetExpectedDocs(bInter, bDebug, StrParam) 
  'This action should not be used, as it is scheduled to be removed in future versions. It has been replaced by rrSet.">
  'DEPRICATED use --> rrSet(@B.ED,value)
  
	SetExpectedDocs = False
	
	StrParam = Trim(StrParam)
	
	If Not IsNumeric(StrParam) then 
		Writelog("Value Must be Numeric.")
		Exit Function
	End if
	SetExpectedDocs = True
	DCO.Variable("ED") = StrParam
	Pilot.ExpectedDocs = StrParam
				

End Function

Function SetExpectedPages(bInter, bDebug, StrParam) 
  'This action should not be used, as it is scheduled to be removed in future versions. It has been replaced by rrSet.">
  'DEPRICATED use --> rrSet(@B.EP,Value)
  
	SetExpectedPages = False
	
	StrParam = Trim(StrParam)
	
	If Not IsNumeric(StrParam) then 
		Writelog("Value Must be Numeric.")
		Exit Function
	End if
	SetExpectedPages = True
	DCO.Variable("EP") = StrParam
	Pilot.ExpectedPages = StrParam
			

End Function

Function AbortOnError(bInter, bDebug, StrParam) 
	AbortOnError = True

	StrParam = Trim(StrParam)

	Select Case ucase(strparam)
		Case "TRUE"
			Writelog("Setting Task to Abort On Errors")
			g_bAbortOnError = True
		Case "FALSE"
			Writelog("Setting Task to Continue On Errors")
			g_bAbortOnError = False
		Case Else
			AbortOnError = False
			Writelog("Invalid Parameter. Expecting 'True' or 'False', received '" & StrParam & "'.")
	End Select		
	
  
End Function

Function PilotMessage_Set(bInter, bDebug, StrParam) 

  Dim sSmartParam

  sSmartParam = MetaWord(StrParam)
  If len(sSmartParam)="" then 
     Writelog("Smart Parameter parsing did not return a value. Defaulting message to the Action argument.")
     sSmartParam =StrParam
  End if
	CurrentObj.Variable("MESSAGE")= Trim(sSmartParam)	
	PilotMessage_Set=True

End Function

Function PilotMessage_Clear(bInter, bDebug) 
	CurrentObj.DeleteVariable("MESSAGE")	
	PilotMessage_Clear=True

End Function

'BEGIN META ACTION SECTION

Function rrSet(varSource,varTarget)
		
  ' rr_Set was replaced by rrSet so we could use the "f" tag with unique parameters.

  Dim aStrParam
	Dim sSource
	Dim sDestination
	Dim sValue
	
	On Error Resume Next
	
	rrSet = False
		
	sSource = Trim(varSource)
	sDestination = Trim(varTarget)
	
	If len(sSource) = 0 Then sSource = DCONavType()
	If len(sDestination) = 0 Then sDestination = DCONavType()

  ' If sSource = sDestination Then we don't care, perform the copy anyway.		
		
	sValue = MetaWord(sSource)    
	rrSet = DCONavSetValue(sDestination,sValue)
	
	Call ErrorHandler("rrSet") 
  
End Function
		
Function rr_Set(bInter, bDebug, StrParam) 

  'This action should not be used, as it is scheduled to be removed in future versions. It has been replaced by rrSet."
  'DEPRECATED 8.1.0.81 5.18.2011
  
  Dim aStrParam
	Dim sSource
	Dim sDestination
	Dim sValue
	
	On Error Resume Next
	
	rr_Set = False
		
	aStrParam = Split(StrParam & ",",",")
	sSource = Trim(aStrParam(0))
	sDestination = Trim(aStrParam(1))
  
  rr_Set = rrSet(sSource, sDestination)
	
	Call ErrorHandler("rr_Set") 
		

End Function

Function rr_Get(bInter, bDebug, StrParam) 
	Dim sValue
	Dim sSource
	Dim sDestination
	
	On Error Resume Next
	
	rr_Get = False
		
	sSource = StrParam
		
	If len(sSource) = 0 Then sSource = DCONavType()
	If len(sDestination) = 0 Then sDestination = DCONavType()
	
  ' This condition will occur only if no parameter is supplied.
	If sSource = sDestination Then 
		Writelog("A parameter is required for rr_Get(). Exiting Action.")
		Exit Function
	End if
		
	sValue = MetaWord(sSource)
	rr_Get = DCONavSetValue(sDestination, sValue)
	
	Call ErrorHandler("rr_Get") 
		

End Function

Function rrCompareCase(object1,object2,caseSensitive)
		
    
  Dim aStrParam
	Dim sSourceA
	Dim sSourceB
	Dim sValueA
	Dim sValueB
	
	On Error Resume Next
	
	rrCompareCase = False
		
	sSourceA = Trim(object1)
	sSourceB = Trim(object2)
  caseSensitive = Trim(caseSensitive)
	
	If len(sSourceA) = 0 Then sSourceA = DCONavType()
	If len(sSourceB) = 0 Then sSourceB = DCONavType()
	
  If sSourceA = sSourceB Then 
    Writelog("Source A and B reference the same component. Returning True.")
    rrCompareCase = True
    Exit Function
  End if
		
	sValueA = MetaWord(sSourceA)
	sValueB = MetaWord(sSourceB)
	
	Writelog("Case Sensitive = '" & UCase(caseSensitive) & "' Comparing: '" & sValueA & "' = '" & sValueB & "'")
	
  dim compareType  
  compareType = 0
  if (UCase(caseSensitive) = "FALSE") Then 
     writelog("Case insensitive comparison")
     compareType = 1
  End if
  
  If StrComp(sValueA, sValueB, compareType) = 0 Then
    rrCompareCase = True
	End if
  
	'If sValueA = sValueB Then
	'	rrCompare = True
	'End if
	
	Call ErrorHandler("rrCompareCase") 
  
End Function
		
Function rrCompare(object1,object2)
		
  ' rr_Compare was replaced by rrCompare so we could use the "f" tag with unique parameters.
	
	On Error Resume Next
	
	rrCompare = rrCompareCase(object1, object2, "TRUE")  
	
	Call ErrorHandler("rrCompare") 
  
End Function
		
Function rr_Compare(bInter, bDebug, StrParam) 
 
  'qi="This action should not be used, as it is scheduled to be removed in future versions. It has been replaced by rrCompare."
  'DEPRECATED 8.1.0.18 5.18.2011 

	Dim aStrParam
	Dim sSourceA
	Dim sSourceB
	Dim sValueA
	Dim sValueB
	
	On Error Resume Next
	
	rr_Compare = False
		
	aStrParam = Split(StrParam & ",",",")
	sSourceA = Trim(aStrParam(0))
	sSourceB = Trim(aStrParam(1))
	
	rr_Compare = rrCompare(sSourceA, sSourceB)
	
	Call ErrorHandler("rr_Compare") 

End Function

Function rrCompareNotCase(object1,object2,caseSensitive)
		
  
  On Error Resume Next
	
	if rrCompareCase(object1, object2, caseSensitive) Then
     rrCompareNotCase = False
  Else
     rrCompareNotCase = True
  End if

	Call ErrorHandler("rrCompareNot") 
  
End Function
		
Function rrCompareNot(object1,object2)
		
  ' rr_Copy was replaced by rrCopy so we could use the "f" tag with unique parameters.
  
  On Error Resume Next
	
	if rrCompare(object1, object2) Then
     rrCompareNot = False
  Else
     rrCompareNot = True
  End if

	Call ErrorHandler("rrCompareNot") 
  
End Function
		
Function rr_Compare_Not(bInter, bDebug, StrParam) 
	On Error Resume Next
	
  'This action should not be used, as it is scheduled to be removed in future versions. It has been replaced by rrCompareNot"
  'DEPRECATED v8.1.0.18 5.18.2011
  
	if rr_Compare(bInter, bDebug, StrParam) Then
     rr_Compare_Not = False
  Else
     rr_Compare_Not = True
  End if

	Call ErrorHandler("rr_Compare_Not") 

End Function

Function rrCompareCaseLength(object1,object2,caseSensitive,length,fromStart)
		

	On Error Resume Next
  Dim nLen
  
  rrCompareCaseLength = false
	
  if (Not (isNumeric(StrParam))) then
     writelog("length parameter '" & length & "' is not numeric.  Returning false")
     Exit Function   
  end if

  nLen = cint(length)
  
  if (nLen <= 0) Then
     writelog("length parameter is 0.  Comparing entire string.")
     rrCompareCaseLength = rrCompareCase(object1, object2, caseSensitive)  
     Exit Function
  End if
 
  Dim sObj1
  Dim sObj2
 
  sObj1 = MetaWord(object1)
  Writelog("Object1 = " & sObj1)
  sObj2 = MetaWord(object2)
  Writelog("Object2 = " & sObj2)

  if (UCASE(fromStart) = "TRUE") Then
     sObj1 = Left(sObj1, nLen)
     sObj2 = Left(sObj2, nLen)
     writelog("Comparing From Start: '" & sObj1 & "' and '" & sObj2 & "'.")
  else
     sObj1 = Right(sObj1, nLen)
     sObj2 = Right(sObj2, nLen)
     writelog("Comparing From End: '" & sObj1 & "' and '" & sObj2 & "'.")
  End if
  
	rrCompareCaseLength = rrCompareCase(sObj1, sObj2, caseSensitive)  
	
	Call ErrorHandler("rrCompare") 
  
End Function
		
Function rrCompareNotCaseLength(object1,object2,caseSensitive,length,fromStart)
		

	On Error Resume Next

  If (rrCompareCaseLength(object1, object2, caseSensitive, length, fromStart)) Then
     rrCompareNotCaseLength = False
  else
     rrCompareNotCaseLength = True
  End If
	
	Call ErrorHandler("rrCompareNotCaseLength") 
  
End Function
		
Function rrCopy(varSource,varTarget)
		
  ' rr_Copy was replaced by rrCopy so we could use the "f" tag with unique parameters.
    
	Dim sSource
	Dim sTarget
	Dim oSource
	Dim oTarget
	Dim sOrigImageN
	Dim sOrigImageH
	Dim oChild
	Dim nChildren
	
	On Error Resume Next

	rrCopy = True
		
	sSource = Trim(varSource)
	sTarget = Trim(varTarget)
	
	If len(sSource) = 0 Then sSource = DCONavType()
	If len(sTarget) = 0 Then sTarget = DCONavType()
	
	If sSource = sTarget Then 
		Writelog("Source and Target are to the same component. Exiting Action.")
		Exit Function
	End if
		
	Set oSource = DCONav(sSource)
	If Not IsAlive(oSource) then 
		Writelog("Copy from node not found.")
		rrCopy=False
		Exit Function
	End if
	
	Set oTarget = DCONav(sTarget)
	If Not IsAlive(oTarget) then 
		Writelog("Copy to node not found.")
		rrCopy=False
		Exit Function
	End if
	
	'Get Target original
		
	'Target original values
	oTarget.Text=""
	oTarget.Variable("Position")="0,0,0,0"
	
	'Check Source has value
	If oSource.Text="" then 
		Writelog("Source field has no value.")
		Exit Function
	End if
	
	Writelog("Copying Node: '" & oSource.ID & "' value:'" & oSource.Text & "' image:'" & oSource.Variable("IMAGEFILE") & "' to '" & oTarget.ID & "'")
	
	Call RRCopyChars(oSource,oTarget,1,len(oSource.Text))
	Call RRCopyPos(oSource,oTarget,1,len(oSource.Text))
	Call RRCopyImage(oSource,oTarget)
		
	Writelog("New Target Value:'" & oTarget.Text & "'  Position:'" & oTarget.Variable("Position") & "' image:'" & oTarget.Variable("IMAGEFILE") & "'")		
				
	Call ErrorHandler("rrCopy")   
  
End Function
		
Function rr_Copy(bInter, bDebug, StrParam) 

  'This action should not be used, as it is scheduled to be removed in future versions. It has been replaced by rrCopy."
  'DEPRECATED v8.1.0.18 5.18.2011
  
	Dim aStrParam
	Dim sSource
	Dim sTarget
	
	On Error Resume Next
		
	aStrParam = Split(StrParam & ",",",")
	sSource = Trim(aStrParam(0))
	sTarget = Trim(aStrParam(1))

  rr_Copy = rrCopy(sSource, sTarget)
				
	Call ErrorHandler("rr_Copy") 		

End Function

Function rrAppend(varSource,varTarget)
		
  ' rr_Append was replaced by rrAppend so we could use the "f" tag with unique parameters.
  Dim sSource
  Dim sTarget
  Dim oSource
  Dim oTarget
  Dim sOrigImageN
  Dim sOrigImageH
  Dim oChild
  Dim nChildren
  Dim oChar
  Dim i

	On Error Resume Next

	rrAppend = True
		
	sSource = Trim(varSource)
	sTarget = Trim(varTarget)
	
	If len(sSource) = 0 Then sSource = DCONavType()
	If len(sTarget) = 0 Then sTarget = DCONavType()
	
	If sSource = sTarget Then 
		Writelog("Source and Target are to the same component. Exiting Action.")
		Exit Function
	End if
		
	sValue = MetaWord(sSource)
	If Len(sValue)=0 then 
		Writelog("Source argument or object does not have a value. Exiting.")
		rrAppend=False
		Exit Function
	End if
	
	Set oTarget = DCONav(sTarget)
	If Not IsAlive(oTarget) then 
		Writelog("Append to node not found.")
		rrAppend=False
		Exit Function
	End if
		
  Writelog("Start Value of Target:'" & oTarget.Text & "'")

	For i = 1 to Len(sValue)
		Set oChar = oTarget.AddChild(4,"",-1)
		
		If Not oChar is Nothing then 
					
			oChar.CharValue(0)= Clng(ASCW(Mid(sValue,i,1)))
			oChar.CharConfidence(0) = Clng(9)
			bRes = oChar.SetPosition(clng(0),clng(0),clng(0),clng(0))
				
		End if
	Next 'x

	Set oChar = Nothing
			
  Writelog("End Value of Target:'" & oTarget.Text & "'")

	Call ErrorHandler("rrAppend")   
  
End Function
		
Function rr_Append(bInter, bDebug, StrParam) 

  'This action should not be used, as it is scheduled to be removed in future versions. It has been replaced by rrAppend."
  'DEPRECATED v8.1.0.18 5.18.2011
  
  Dim aStrParam
  Dim sSource
  Dim sTarget

	On Error Resume Next

	aStrParam = Split(StrParam & ",",",")
	sSource = Trim(aStrParam(0))
	sTarget = Trim(aStrParam(1))

  rr_Append = rrAppend(sSource, sTarget)

	Call ErrorHandler("rr_Append") 

End Function

Function rrPrepend(varSource,varTarget)
		
  ' rr_Append was replaced by rrAppend so we could use the "f" tag with unique parameters.  
	Dim sSource
	Dim sTarget
	Dim oSource
	Dim oTarget
	Dim sOrigImageN
	Dim sOrigImageH
	Dim oChild
	Dim nChildren
	Dim oChar
  Dim i

	On Error Resume Next

	rrPrepend = True
		
	sSource = Trim(varSource)
	sTarget = Trim(varTarget)
	
	If len(sSource) = 0 Then sSource = DCONavType()
	If len(sTarget) = 0 Then sTarget = DCONavType()
	
	If sSource = sTarget Then 
		Writelog("Source and Target are to the same component. Exiting Action.")
		Exit Function
	End if
		
	sValue = MetaWord(sSource)
	If Len(sValue)=0 then 
		Writelog("Source argument or object does not have a value. Exiting.")
		rrPrepend=False
		Exit Function
	End if
	
	Set oTarget = DCONav(sTarget)
	If Not IsAlive(oTarget) then 
		Writelog("Append to node not found.")
		rrPrepend=False
		Exit Function
	End if
		
  Writelog("Start Value of Target:'" & oTarget.Text & "'")

	For i = 1 to Len(sValue)
		Set oChar = oTarget.AddChild(4,"",i-1)
		
		If Not oChar is Nothing then 
					
			oChar.CharValue(0)= Clng(ASCW(Mid(sValue,i,1)))
			oChar.CharConfidence(0) = Clng(9)
			bRes = oChar.SetPosition(clng(0),clng(0),clng(0),clng(0))
				
		End if
	Next 'x

	Set oChar = Nothing
			
  Writelog("End Value of Target:'" & oTarget.Text & "'")

	Call ErrorHandler("rrPrepend") 
  
End Function
		
Function rr_Prepend(bInter, bDebug, StrParam) 
  
  'This action should not be used, as it is scheduled to be removed in future versions. It has been replaced by rrPreped."
  'DEPRECATED v8.1.0.18 5.18.2011
  
  Dim aStrParam
	Dim sSource
	Dim sTarget

	On Error Resume Next

	aStrParam = Split(StrParam & ",",",")
	sSource = Trim(aStrParam(0))
	sTarget = Trim(aStrParam(1))

	rr_Prepend = rrPrepend(sSource, sTarget)

	Call ErrorHandler("rr_Prepend") 

End Function

'END META ACTION SECTION

Function rr_WriteNode(bInter, bDebug) 
		
	Dim sNodeFileName	
	
	On Error Resume Next 
	
	rr_WriteNode=True
	
	sNodeFileName=Pilot.BatchDir & "\" & CurrentObj.ID & ".xml"
		
	CurrentObj.Variable("DATAFILE")=sNodeFileName
		

End Function

Function rr_AbortBatch(bInter, bDebug) 
  	rr_AbortBatch = False
    
    Call AbortBatch()  


End Function

Sub AbortBatch() 
  ' Sets the Batch to Abort
  
    Writelog("Setting Batch to stop processing rules and end with status ABORTED.")
    
    bAbort = True
    nTaskStatus = RetAbort 
      RRState.Data("bAbort")="True"
      RRState.LogicResult=-1  


End Sub

Function GotoNextRule(bInter, bDebug) 
  '"This action should not be used, as it is scheduled to be removed in future versions. It has been replaced by GoToNextFunction."
	'This action has been deprecated. It has been replaced by "GoToNextFunction".
	GoToNextRule = False
	GoToNextRule = GoToNextFunction()

End Function

Function GoToNextFunction()
		
	GoToNextFunction = False
	WriteLog("GoToNextFunction returning " & GoToNextFunction & " so next function in the RuleSet will run.") 
	'Call ErrorHandler("Function GoToNextFunction") 

End Function
		
Function SetReturnValue(bInter, bDebug, StrParam) 
	on error resume next
  
  SetReturnValue = False
  
  StrParam = Trim(StrParam)  
  if (ucase(StrParam) = "TRUE") then
    SetReturnValue = True
  end if      
  Writelog("SetReturnValue returns: " & SetReturnValue)
  
End Function

Function ProcessChildren(bInter, bDebug, StrParam) 
	Dim aStrParam

  On Error Resume Next

  ProcessChildren = FALSE

  aStrParam = Split(StrParam,",")

  If uBound(aStrParam) <> 1 then
    Writelog("Expecting comma separated arguments (Condition,Command). Wrong number of parameters. Exiting")
    Exit Function
  End if

  Call u_RecurseObject(CurrentObj,aStrParam(0),aStrParam(1),cint(0))

  ProcessChildren = TRUE
  

End Function

Function u_RecurseObject(Obj,Condition,Command,Indent)
		
' utility function for ProcessChildren Action

	Dim i
  Dim NextIndent
  Dim nChildren
  
  On Error Resume Next
  
  Writelog(space(Indent) & "-- ProcessChild '" & Obj.ID & "'")

  If Eval(Condition) then
    Writelog(space(Indent) & "   * Condition Found: " & Condition)
    Writelog(space(Indent)& "   * Executing Command: " & Command)
    Execute(Command)
  End if

  If Err.Number<>0 then Exit function

  NextIndent = Indent + cint(3)

  'Count of child objects -  character obj count
  nChildren = Obj.NumOfChildren - len(Obj.Text)

  For i = 1 to nChildren
    Call u_RecurseObject(Obj.GetChild(i-1),Condition,Command,NextIndent)
  Next 'i


End Function
		
Function SetBatchPriority(Priority)
		
' Sets the Batch priority for the current Batch
   
  On Error Resume Next
  
  Dim SmartVal
  
  SetBatchPriority=False
  
  SmartVal=MetaWord(Priority)
  If Len(SmartVal)>0 then Priority=SmartVal
  
  If Not Isnumeric(Priority) Then 
    Writelog("Parameter must be numeric.")
    Exit Function
  End if
  
  Priority=cInt(Priority)
  
  If Priority<0 Then 
    Writelog("Parameter must be a non negative integer.")
    Exit Function
  End if
  
  Pilot.Priority=Priority 
  
  If Err.Number=0 then
    SetBatchPriority=True
    Writelog("Batch Priority set to '" & cStr(Priority) & "'")
  End if
 

End Function
		
Function SetOperatorID(OperatorID)
		
' Sets the Batch OperatorID for the current Batch
   
  On Error Resume Next
  
  Dim sSmartVal
  
  SetOperatorID=False
      
  SmartVal=MetaWord(OperatorID)
  If Len(SmartVal)>0 then OperatorID=SmartVal
    
  Pilot.Operator=cstr(OperatorID) 
  
  If Err.Number=0 then
    SetOperatorID=True
    Writelog("Operator set to '" & OperatorID & "'")
  End if
 

End Function
		
Function SetStationID(StationID)
		
' Sets the Batch StationID for the current Batch
   
  On Error Resume Next
  
  Dim sSmartVal
  
  SetStationID=False
      
  SmartVal=MetaWord(StationID)
  If Len(SmartVal)>0 then StationID=SmartVal
  
  Pilot.Station=cStr(StationID) 
  
  If Err.Number=0 then
    SetStationID=True
    Writelog("Station set to '" & StationID & "'")
  End if
 

End Function
		'namespace ()
                'include (rrunner)

'*********************************
'FPXML Actions

' Licensed Materials - Property of IBM
' “Restricted Materials of IBM”
' 5725-C15 5725-C69
'
' © Copyright IBM Corp. 1994, 2016 All Rights Reserved
'
' US Government Users Restricted Rights - Use, duplication or
' disclosure restricted by GSA ADP Schedule Contract with
' IBM Corp.
'*********************************
Writelog("FPXML action library version 9.1.0.18")

Dim FPXMLWrapper
Dim m_sDetailType
Dim m_sLineItemType
Dim m_sFingerprintDir

m_sDetailType = ""
m_sLineItemType = ""

On Error Resume Next

Set FPXMLWrapper = CreateObject("dcctlNET.FingerprintzXML")

If Err.Number <> 0 Then
  Writelog "Could not instantiate fpxml wrapper class"
  Err.Clear
End If

'Wrapper Methods:
'public bool OpenFingerprint(string FingerprintDirectory, string FingerprintID, bool Create)
'public bool AddFieldInfo(string FieldName, string FieldPosition)
'public string[] GetFingerprintFieldList()
'public string GetFieldInfo(string FieldName)
'public bool UpdateFieldName(string FieldName, string NewFieldName)
'public bool UpdateFPrint(string Type, string HostName, string HostID)
'public bool RemoveField(string FieldName)
'public bool Save()

'*********************************

Sub ZoneChildrenFPX(oObj,PosName,byVal oSet,byVal Xadj,byVal Yadj) 
	Dim oSetupNode
	Dim oSubRule
	Dim oSubChar
	Dim nChar
	Dim sZonePos
	Dim arZonePos
				
	On error resume Next
  Writelog "Processing children for object " & oObj.ID
	oSet = oSet + 4
	nCount=oObj.NumOfChildren()-len(oObj.Text)
  Writelog "Number of children " & nCount
  
  'Special handling for Detail fields
  If "" <> m_sDetailType And "" <> m_sLineItemType Then
    
    If LCase(oObj.Type) = LCase(m_sDetailType) Then
          Writelog "Starting special handling of field " & oObj.ID
          oObj.Variable("LineItemPos") = FPXMLWrapper.GetFieldInfo(m_sLineItemType)
          Set oSetupNode = oObj.SetupNode()  
          For nChar = 1 to oSetupNode.NumOfRules
			      Set oSubRule = oSetupNode.GetRule(nChar-1)
            If Not(oSubRule is Nothing) then
  			      Writelog "Analyzing field " & oSubRule.Name
              
              If LCase(oSubRule.Name) = LCase(m_sLineItemType) Then					
				        Writelog oSubRule.Name & " is the line item field. Analyzing subfields?..."
                'Writelog "Count :" & oSubRule.NumOfRules
                For nChar2 = 1 to oSubRule.NumOfRules
                  Set oSubRule2 = oSubRule.GetRule(nChar2-1)
                  
                  If Not(oSubRule2 is Nothing) Then
                    writelog "field: " & oSubRule2.Name
                    
                    sZonePos = FPXMLWrapper.GetFieldInfo(oSubRule2.Name)
                    writelog(space(oSet+2) & "Found ZonePos: " & sZonePos)
				            If sZonePos <> "" and sZonePos <> "0,0,0,0" Then
					            'writelog "zone found " & sZonePos
                      arZonePos=split(sZonePos,",")
					            If UBound(arZonePos)=3 Then
      								
						            arZonePos(0)=arZonePos(0)+Xadj
						            arZonePos(1)=arZonePos(1)+Yadj
						            arZonePos(2)=arZonePos(2)+Xadj
						            arZonePos(3)=arZonePos(3)+Yadj
      								
                        oObj.Variable("POS-" & oSubRule2.Name) = clng(arZonePos(0)) & "," & clng(arZonePos(1)) & "," & clng(arZonePos(2)) & "," & clng(arZonePos(3))
                        writelog "updated zone " & clng(arZonePos(0)) & "," & clng(arZonePos(1)) & "," & clng(arZonePos(2)) & "," & clng(arZonePos(3))
					            End If
				            End If
                  End If
                Next  
              End If
			      End If
		      Next 'nChar
	  End If 
	
  End If
  
  For i=0 To nCount-1
		Set oChild=oObj.GetChild(i)
		
		If Not oChild Is Nothing Then
			If oChild.ObjectType < 4 then 
				
				sZonePos = FPXMLWrapper.GetFieldInfo(oChild.ID)
        Writelog "Field zones is " & sZonePos
				If sZonePos <> "" and sZonePos <> "0,0,0,0" and Not(CurrentObj.Variable("PatternMatch")="1") then
					arZonePos=split(sZonePos,",")
					If UBound(arZonePos)=3 Then
						arZonePos(0)=arZonePos(0)+Xadj
						arZonePos(1)=arZonePos(1)+Yadj
						arZonePos(2)=arZonePos(2)+Xadj
						arZonePos(3)=arZonePos(3)+Yadj
						oChild.Variable("Position")=CStr(arZonePos(0)) & "," & CStr(arZonePos(1)) & "," & CStr(arZonePos(2)) & "," & CStr(arZonePos(3))
						'Writelog(space(oSet) & "Set " & oChild.ID & " from Position to " & sZonePos & " to " & oChild.Variable("Position"))
					End If 'UBound(arZonePos)=3
				End If 'sZonePos <> ""...
				
				Set oSetupNode = oChild.SetupNode()
				If Not(oSetupNode is Nothing) then 
					If oSetupNode.variable("RecogType")="4" then
						writelog(space(oSet+2) & "OMR recogtype found.") 
						For nChar = 1 to oSetupNode.NumOfRules
							Set oSubRule = oSetupNode.GetRule(nChar-1)
							Set oSubChar = oChild.GetChild(nChar-1)
							If Not(oSubRule is Nothing) then
								If oSubChar is Nothing then 
									Set oSubChar = oChild.AddChild(4, "", -1)
								End if ' oSubChar is Nothing
							
								sZonePos = FPXMLWrapper.GetFieldInfo(oSubRule.Name)
								writelog(space(oSet+2) & "Found ZonePos: " & sZonePos)
								If sZonePos <> "" and sZonePos <> "0,0,0,0" then
									arZonePos=split(sZonePos,",")
									If UBound(arZonePos)=3 Then
										
										arZonePos(0)=arZonePos(0)+Xadj
										arZonePos(1)=arZonePos(1)+Yadj
										arZonePos(2)=arZonePos(2)+Xadj
										arZonePos(3)=arZonePos(3)+Yadj
										
										bRes = oSubChar.SetPosition(clng(arZonePos(0)) ,clng(arZonePos(1)),clng(arZonePos(2)),clng(arZonePos(3)))
										bRes = oSubChar.GetPosition(clng(arZonePos(0)) ,clng(arZonePos(1)),clng(arZonePos(2)),clng(arZonePos(3)))

									End If 'If UBound(arZonePos)=3
								End If ' sZonePos <> "" and 
							End If 'Not(oSubRule is Nothing) 
						Next 'nChar
           End If 'oSetupNode.variable("RecogType")="4"
      	End If 'Not(oSetupNode is Nothing)
				Set oSetupNode = Nothing
				Call ZoneChildrenFPX(oChild, PosName, oSet, Xadj, Yadj)
			End If 'If oChild.ObjectType < 4
		End If 'If Not oChild Is Nothing
	Next
	

End Sub

Sub CalculateLineItemPosFPX(oLineItem) 
  Dim i
  Dim x1
  Dim y1
  Dim x2
  Dim y2
  Dim Pos
  Dim ParamAr
  Dim oSubField
   Writelog("Calculating LineItemPos") 
   Pos = oLineItem.Parent.Variable("Position")
   Writelog("DetailPos = " & Pos)
   ParamAr = Split(Pos,",")   
   x1 = cStr(cLng(ParamAr(0)) + 2)
   y1 = 1000000
   x2 = cStr(cLng(ParamAr(2)) - 2)
   y2 = 0
   Writelog("Processing " & cStr(oLineItem.NumOfChildren) & " subfields")
   For i = 0 to oLineItem.NumOfChildren - 1
      Set oSubField = oLineItem.GetChild(i)
      Writelog("Reading positions for: " & oSubField.Type)
      Pos = oSubField.Variable("Position")
      Writelog("SubFieldPos = " & Pos)
      if Pos <> "" AND Pos <> "0,0,0,0" then 
         ParamAr = Split(Pos,",")
         if y1 > cLng(ParamAr(1)) - 1  then
            y1 = cLng(ParamAr(1)) - 1 
            Writelog("y1 set to: " & cStr(y1))
         end if
         if y2 < cLng(ParamAr(3)) + 1 then
            y2 = cLng(ParamAr(3)) + 1
            Writelog("y2 set to: " & cStr(y2))
         end if
      end if
   next 'i
   
   oLineItem.Parent.Variable("LineItemPos") = cStr(x1) & "," & cStr(y1) & "," & cStr(x2) & "," & cStr(y2)


End Sub

Function WriteDetailFieldFPX(oField)
		
   
   Writelog("Writing Detail Field: " & oField.ID & "," & oField.Type)
   
   If oField.GetChild(0) Is Nothing Then
    Writelog "Skipping details field as it does not contain any lineitem children fields."
    Exit Function
   End If
   
   If oField.GetChild(0).ObjectType <> 3 Then
      Writelog("Skipping details field as it does not contain a valid lineitem child field.")
      Exit Function
   End if
   
   l_sVarName = ""
   l_sVarValue = ""
   l_iNumVars = oField.NumOfVars
   Writelog oField.Type & " contains " & l_iNumVars & " variable with possible line item positions."
   
   If Trim(oField.Variable("Position")) <> "" AND Trim(oField.Variable("Position")) <> "0,0,0,0" Then 
        FPXMLWrapper.AddFieldInfo oField.ID,oField.Variable("Position")
        Writelog "Writing zones for field " & oField.ID 
   End If 
   
   For i=0 to l_iNumVars - 1
      l_sVarName = oField.GetVariableName(i)
      l_sVarValue = oField.GetVariableValue(i)
      
      If Left(l_sVarName,4) = "POS-" Then
          Writelog "Variable " & l_sVarName & " is a position variable. Processing..."
          l_sVarName = Replace(l_sVarName,"POS-","")
          
          If Trim(l_sVarValue) <> "" AND Trim(l_sVarValue) <> "0,0,0,0" Then 
                Writelog "Saving positions for field " & l_sVarName & ": " & l_sVarValue
                FPXMLWrapper.AddFieldInfo l_sVarName,l_sVarValue
                Writelog "Saved." 
          End If 
      Else
          If l_sVarName = "LineItemPos" Then
              Writelog "Saving special Lineitem field. Value: " & l_sVarValue
              FPXMLWrapper.AddFieldInfo "Lineitem",l_sVarValue
          Else
            Writelog "Variable " & l_sVarName & " is not a position variable (POS- or LineItemPos). Skipping..."
          End If
      End If
   Next


End Function
		
Sub WriteChildrenZonesFPX(pObject) 
      
      Dim oField
      
      For i = 0 to pObject.NumOfChildren - 1
        Set oField = pObject.GetChild(i)
      
        If oField.ObjectType = 3 Then
         
          If Trim(oField.Variable("Position")) <> "" AND Trim(oField.Variable("Position")) <> "0,0,0,0" Then 
                FPXMLWrapper.AddFieldInfo oField.ID,oField.Variable("Position")
                Writelog "Writing zones for field " & oField.ID 
          End If 
         
          If oField.NumOfChildren <> 0 Then
            Call WriteChildrenZonesFPX(oField) 
          End If
         
        End if
      Next 'i
      
      Set oField = Nothing
      
End Sub

Function FindFieldFPX(pParent,pChildName)
		
      
      Dim n_lnFound 
      Dim l_bFound
      Dim oField 
      Set oField = Nothing
      
      l_bFound = false
      
      If pParent.ID = pChildName Then
        l_bFound = True
      Else
        l_bFound = False
      End If 
      
      If l_bFound Then
         Set FindFieldFPX = pParent
         Exit Function
      End If
      
      For i = 0 To pParent.NumOfChildren - 1
        
        Set oField = FindFieldFPX (pParent.GetChild(i),pChildName)
        
        If Not oField is Nothing Then
            Exit For
        End If
      Next 'i
      
      Set FindFieldFPX = oField
      
End Function
		
Function ReadZonesFPX(bInter, bDebug) 
	Dim sName	
	Dim PosName
	Dim sOffSet
	Dim aOffSet
	Dim nXoffset
	Dim nYoffset
	Dim oCurPage
	Dim bPos
	Dim bPM
	
  ReadZonesFPX = False
  
  sFingerprintDir = m_sFingerprintDir
   
  If Trim(sFingerprintDir) = "" Then
      Writelog "The fingerprint directory has not been set. Exiting."
      Exit Function
  End If
  
  If Right(FingerprintDir,1) <> "\" Then
    FingerprintDir = FingerprintDir & "\"
  End If 
  
	sOffSet = ""

	Set oCurPage = CurrentObj
	
	sOffSet=oCurPage.Variable("Image_Offset")
	
	While oCurPage.ObjectType<>2 AND oCurPage.ObjectType>1
		Set oCurPage = oCurPage.Parent()
		If len(sOffSet)=0 then sOffSet=oCurPage.Variable("Image_Offset")
	Wend

	sName=oCurPage.Variable("TemplateID")	
	PosName = "Pos" & sName
	Writelog("ReadZones for " & PosName)
  
  If Not FPXMLWrapper.OpenFingerprint(sFingerprintDir, sName, False) Then
    Writelog "Could not open the fingerprint information: " & FPXMLWrapper.LastError
    Exit Function
  End If

	aOffSet = Split(sOffSet & ",0" , ",")

  If sOffSet <> "" Then
	  nXoffset = (-1*aOffSet(0))
	  nYoffset = (-1*aOffSet(1))
  End If
  
	If Not(Isnumeric(nXoffSet)) or len(trim(nXoffSet))=0 then 
		nXoffset = 0
		writelog("X offset value was not numeric or empty. Setting value to Zero.")
	end if

	If Not(Isnumeric(nYoffSet)) or len(trim(nYoffSet))=0 then 
		nYoffset = 0
		writelog("Y offset value was not numeric or empty. Setting value to Zero.")
	end if
	
	Writelog("Offsets : " & nXoffset & "," & nYoffset)
	
	oSet = 0
	xAdj = clng(nXoffSet)
	Yadj = clng(nYoffSet)

	If CurrentObj.ObjectType < 4 then 
				
		sZonePos = FPXMLWrapper.GetFieldInfo(CurrentObj.ID)
		writelog("DCO pos:" & sZonePos)
		bPM = Not(CurrentObj.Variable("PatternMatch")="1")
		bPos = CurrentObj.Variable("Position")="0,0,0,0" or CurrentObj.Variable("Position")="" 
		If sZonePos <> "" and sZonePos <> "0,0,0,0" and bPM and bPos then
			arZonePos=split(sZonePos,",")
			If UBound(arZonePos)=3 Then
				arZonePos(0)=arZonePos(0)+Xadj
				arZonePos(1)=arZonePos(1)+Yadj
				arZonePos(2)=arZonePos(2)+Xadj
				arZonePos(3)=arZonePos(3)+Yadj
				CurrentObj.Variable("Position")=CStr(arZonePos(0)) & "," & CStr(arZonePos(1)) & "," & CStr(arZonePos(2)) & "," & CStr(arZonePos(3))
				writelog("new pos:" & CurrentObj.Variable("Position"))		
			End if
		End if
				
		Set oSetupNode = CurrentObj.SetupNode()
		If Not(oSetupNode is Nothing) then 
			If oSetupNode.variable("RecogType")="4" then
				writelog(space(oSet+2) & "OMR recogtype found.") 
				For nChar = 1 to oSetupNode.NumOfRules
					Set oSubRule = oSetupNode.GetRule(nChar-1)
					Set oSubChar = CurrentObj.GetChild(nChar-1)
					If Not(oSubRule is Nothing) then
						If oSubChar is Nothing then 
							Set oSubChar = CurrentObj.AddChild(4, "", -1)
						End if
							
						sZonePos = FPXMLWrapper.GetFieldInfo(oSubRule.Name)
						writelog(space(oSet+2) & "Found ZonePos: " & sZonePos)
						if sZonePos <> "" and sZonePos <> "0,0,0,0" then
							arZonePos=split(sZonePos,",")
							If UBound(arZonePos)=3 Then
										
								arZonePos(0)=arZonePos(0)+Xadj
								arZonePos(1)=arZonePos(1)+Yadj
								arZonePos(2)=arZonePos(2)+Xadj
								arZonePos(3)=arZonePos(3)+Yadj
										
								bRes = oSubChar.SetPosition(clng(arZonePos(0)) ,clng(arZonePos(1)),clng(arZonePos(2)),clng(arZonePos(3)))
								bRes = oSubChar.GetPosition(clng(arZonePos(0)) ,clng(arZonePos(1)),clng(arZonePos(2)),clng(arZonePos(3)))

								'writelog("Saved X Y (" & CStr(arZonePos(2)- arZonePos(0)) & "," & CStr(arZonePos(3)-arZonePos(1)) & ") " & vbcrlf)

							end if
						end if
					End If
				Next 'nChar
			End If
		End If
		Set oSetupNode = Nothing
    
		Call ZoneChildrenFPX(CurrentObj, PosName, oSet, Xadj, Yadj)

	End if
  
  ReadZonesFPX = True


End Function

Function SetDetailsAndLineitemPairFPX(bInter, bDebug, StrParam) 
	
  SetDetailsAndLineitemPairFPX = False
  
  ParamAr = Split(StrParam,",")
  
  If UBound(ParamAr) < 1 Then
    Writelog "Invalid parameter count: this action expects two parameters. Exiting."
  Else
    m_sDetailType = MetaWord(ParamAr(0))
    m_sLineItemType = MetaWord(ParamAr(1))
    
    Writelog "Detail field type set to " & m_sDetailType
    Writelog "Lineitem field type set to " & m_sLineItemType
    SetDetailsAndLineitemPairFPX = True
  End If


End Function

Function SetDirectoryFPX(bInter, bDebug, StrParam) 
	
  SetDirectoryFPX = False
  
  If Len(Trim(StrParam)) = 0 Then
    Writelog "Invalid parameter: this action expects the fingeprint directory. Exiting."
  Else
    m_sFingerprintDir = MetaWord(StrParam)
    
    If Right(m_sFingerprintDir,1) <> "\" then
      m_sFingerprintDir = m_sFingerprintDir & "\"
    End If
   
    Writelog "Fingerprint directory set to " & m_sFingerprintDir
    SetDirectoryFPX = True
  End If


End Function

Function WriteZoneFPX(bInter, bDebug, StrParam) 
  
   Dim ParamAr
   Dim oPage
   Dim sFingerprint
   Dim sFingerprintDir
   Dim i
   Dim oField
   Dim sFieldName
  
   WriteZoneFPX = False

   If CurrentObj.ObjectType <> 2 And CurrentObj.ObjectType <> 3 then
      Writelog("This action runs at the page and field levels only.  Exiting")
      Exit Function
   End If

   sFieldName = MetaWord(StrParam)
   
   Set oPage = CurrentObj
   
   While oPage.ObjectType > 2
        Set oPage = oPage.Parent
   Wend 
        
   sFingerprint = oPage.Variable("TemplateID")
   
   If Trim(sFingerprint) = "" Then
      Writelog "Could not find a fingerprint ID for this field. Exiting"
      Exit Function
   End If
   
   If sFieldName = "" Then
      If oPage.ObjectType = 3 Then
        sFieldName = CurrentObj.ID
      Else
        Writelog "When called at the page level, the field name parameter is required. Exiting"
        Exit Function
      End If
   End If
  
   sFingerprintDir = m_sFingerprintDir
   
   If Trim(sFingerprintDir) = "" Then
      Writelog "The fingerprint directory has not been set. Exiting."
      Exit Function
   End If
    
   sFingerprint = oPage.Variable("TemplateID")

   Set oFS = CreateObject("Scripting.FileSystemObject")
   
   If Not oFS.FolderExists(sFingerprintDir) then
      Writelog("Could not find: " & sFingerprintDir)
      oFS.CreateFolder(sFingerprintDir)
      Writelog("Created: " & sFingerprintDir)
   End If
   
   If Not FPXMLWrapper.OpenFingerprint(sFingerprintDir, sFingerprint, true) Then
      Writelog "Could not open the fingerprint information: " & FPXMLWrapper.LastError
      Exit Function
   End If
   
   Set oField = FindFieldFPX(CurrentObj,sFieldName)
   
   If oField Is Nothing Then
     Writelog "Could not find the field " & sFieldName & " . Exiting."
     Exit Function
   Else
    Writelog "Field " & oField.ID & " found."
   End If
   
   If oField.Type = m_sDetailType Then
      writelog "Writing details field to fingerprint " & sFingerprint
      Call WriteDetailFieldFPX(oField)
   Else
      writelog "Writing normal field to fingerprint " & sFingerprint & "," & oField.Variable("Position")
      FPXMLWrapper.AddFieldInfo oField.ID,oField.Variable("Position")
      Writelog "Last error : " & FPXMLWrapper.LastError
   End If
   
   If FPXMLWrapper.Save Then
      Writelog "Page zones saved to FPXML."
      WriteZoneFPX = True
   Else
      Writelog "The page zones could not be written to the fingerprint XML file :" & FPXMLWrapper.LastError
      WriteZoneFPX = False
   End If
   

End Function

Function WriteZonesFPX(bInter, bDebug, StrParam) 
  
  Dim ParamAr
  Dim oPage
  Dim sFingerprint
  Dim sFingerprintDir
  Dim sHostName
  Dim sHostID
  Dim oFS
  Dim FPXMLFile
  Dim i
  Dim oField
  
  sHostName = ""
  sHostID = ""
  
   WriteZonesFPX = False

   if CurrentObj.ObjectType <> 2 then
      Writelog("Action belongs on a page level only.  Exiting")
      Exit Function
   End if

   ParamAr = Split(StrParam,",")

   sFingerprintDir = m_sFingerprintDir
   
   if Right(sFingerprintDir,1) <> "\" then
      sFingerprintDir = sFingerprintDir & "\"
   end if
   
   If Trim(sFingerprintDir) = "" Then
      Writelog "The fingerprint directory has not been set. Exiting."
      Exit Function
   End If
      
   If uBound(ParamAr) >= 0 Then sHostName = MetaWord(ParamAr(0))
  
   If uBound(ParamAr) >= 1 then sHostID = MetaWord(ParamAr(1))
   
   Set oPage = CurrentObj
 
   sFingerprint = oPage.Variable("TemplateID")

   If uBound(ParamAr) >= 2 then
      sPageType = MetaWord(ParamAr(2))
   Else
      sPageType = oPage.Type
   End if
   
   writelog("Fingerprint ID " & sFingerprint)

   Set oFS = CreateObject("Scripting.FileSystemObject")
   
   If Not oFS.FolderExists(sFingerprintDir) then
      Writelog("Could not find: " & sFingerprintDir)
      oFS.CreateFolder(sFingerprintDir)
      Writelog("Created: " & sFingerprintDir)
   End If

   If sHostID = "" Then
      sHostID = ""
   End If

   If sHostName = "" then
      sHostName = ""
   End If
  
   Writelog "Fingerprint directory : " & sFingerprintDir
   
   If Not FPXMLWrapper.OpenFingerprint(sFingerprintDir, sFingerprint, true) Then
      Writelog "Could not open the fingerprint information: " & FPXMLWrapper.LastError
      Exit Function
   End If
   
   Writelog "Fingerprint page type set to " & sPageType
   Writelog "Fingerprint host name set to " & sHostName
   Writelog "Fingerprint host id   set to " & sHostID
   
   FPXMLWrapper.UpdateFPrint sPageType,sHostName ,sHostID

   Writelog "Saving zones..." 
    
   For i = 0 to oPage.NumOfChildren - 1
      Set oField = oPage.GetChild(i)
      
      If Not oField Is Nothing Then
        If oField.ObjectType = 3 Then
           If oField.Type = m_sDetailType Then
              Call WriteDetailFieldFPX(oField)
           Else
              If Trim(oField.Variable("Position")) <> "" AND Trim(oField.Variable("Position")) <> "0,0,0,0" Then 
                  FPXMLWrapper.AddFieldInfo oField.ID,oField.Variable("Position")
                  Writelog "Writing zones for field " & oField.ID 
              End If 
            
              If oField.NumOfChildren <> 0 Then
                Call WriteChildrenZonesFPX(oField) 
              End If
           End If
        End If
      End If
   Next 'i
   
   If FPXMLWrapper.Save Then
      Writelog "Finished saving zones."
      WriteZonesFPX = True
   Else
      Writelog "The page zones could not be written to the fingerprint XML file :" & FPXMLWrapper.LastError
      WriteZonesFPX = False
   End If
   

End Function
'namespace ()
                'include (rrunner)

'************************************************************************
' Batch Split Actions
'
' Licensed Materials - Property of IBM
' "Restricted Materials of IBM"
' 5725-C15 5725-C69
'
' (c) Copyright IBM Corp. 1994, 2014 All Rights Reserved
'
' US Government Users Restricted Rights - Use, duplication or
' disclosure restricted by GSA ADP Schedule Contract with
' IBM Corp.
'
'------------------------------------------------------------------------
' LOG VERSION:
'Note: 9.0.0.26 populated via RRX.cs
Writelog("Split version 9.0.0.26")
'********************************************************************

' DEFINED IN RRUNNER.RRX
' Const DCO_BATCH = 0
' Const DCO_DOCUMENT=1
' Const DCO_PAGE=2
	
Const ForReading = 1
Const ForWriting = 2
Const ForAppending = 8

Dim dictBuckets ' a list of all the different values that are going to be split
Dim sBucketName
Dim sStatID
Dim sScanUser
Dim oSaveCurrentObj

'Comm object for converting between Int and AlphaDecimal
Set oDCBase36 = Createobject("Datacap.DCName.DatacapBase36")

If IsObject(oDCBase36) then
  Writelog("DatacapBase36 Object Created")
Else
  Writelog("Failed to Create DatacapBase36 Object")
End if


Function ErrorHandler(DescString)
		

	Dim eStr
	
	If Err.Number <> 0 Then		
		eStr = ""
		eStr = eStr & Space(1) & vbCrLf
		eStr = eStr & Space(1) & vbCrLf
		eStr = eStr & vbCrlf & String(40,"*") & vbCrLf
		eStr = eStr & "* ERROR! - " & DescString & vbCrlf
		eStr = eStr & "* DESCRIPTION: " & Err.Description & vbCrLf
		eStr = eStr & "*  NUMERIC ID: " & CStr(Err.Number) & vbCrLf
		eStr = eStr & "*      SOURCE: " & Err.Source & vbCrLf
		eStr = eStr & String(40,"*") & vbCrlf & vbCrLf

		Call Writelog(eStr)
		
		Err.Clear
	End If
	
End Function
		
Function ErrorHandlerMoveFile(SrcPath,DestPath,ChkExists)
		
	ErrorHandlerMoveFile = TRUE
	ChkExists = CBool(ChkExists)
	If (ChkExists) AND (Not FileMgr.FileExists(SrcPath)) Then Exit Function

	On Error Resume Next
	Call FileMgr.MoveFile(SrcPath, DestPath)
	If Err.Number <> 0 Then
		WriteLog "*** Error moving " & SrcPath & " ***"
		Call ErrorHandler("MoveFile")
		bAbort = True
		nTaskStatus = RetAbort
		ErrorHandlerMoveFile = FALSE
	End IF
	On Error Goto 0
	
End Function
		
Function SplitAPage(oPage,oSplitDCO,sBatchPath)
		

	'SplitAPage - split a single page to new batch
	' params = oPage - page to be split/moved, oSplitDCO - batch or doc DCO to add it into
	' locals sPageID, oPageAdded, iDiv, snPage, soPage: returns T/F
	Dim oPageAdded
	Dim iDiv
	Dim snPage
	Dim soPage
	Dim sDataFile

	SplitAPage = False
	
	soPage = oPage.ImageName	' this automatically adds the full path!
	'iDiv = InStrRev(soPage, ".")
	'soPage = Left(soPage, iDiv-1)
	iDiv = InStrRev(soPage, "\") ' to the right of this is the filename and suffix TM000001.tif
	snPage = sBatchPath  & "\"	' new location of image file (folder)

	'-----Start moving files-----
	'Move image file TM*.tif
	Writelog "Move " & soPage & " to " & snPage
	If Not ErrorHandlerMoveFile(soPage, snPage, False) Then Exit Function

	'Try to move other files (TM*.xml, TM*.tio, TM*.cco, etc.) if present
	iDiv = InStrRev(soPage, ".")
	soPage = Left(soPage, iDiv-1)
	soPage = soPage & ".xml"
	If Not ErrorHandlerMoveFile(soPage, snPage, True) Then Exit Function

	soPage = Left(soPage, iDiv-1)
	soPage = soPage & ".tio"
	If Not ErrorHandlerMoveFile(soPage, snPage, True) Then Exit Function

	soPage = Left(soPage, iDiv-1)
	soPage = soPage & ".cco"
	If Not ErrorHandlerMoveFile(soPage, snPage, True) Then Exit Function

	soPage = Left(soPage, iDiv-1)
	soPage = soPage & ".ti1"
	If Not ErrorHandlerMoveFile(soPage, snPage, True) Then Exit Function
	'-----Finished moving files-----

	sPageID = oPage.ID
	' recreate the new image filename (.tif) as snPage
	soPage = oPage.ImageName	' this automatically adds the full path
	iDiv = InStrRev(soPage, "\") ' to the right of this is the filename and suffix TM000001.tif
	snPage = sBatchPath & Mid(soPage, iDiv)
	WriteLog("Insert page ID: " & sPageID & " ImageName: " & snPage)
	Set oPageAdded = oSplitDCO.AddChild(DCO_PAGE, sPageID, -1)
	oPageAdded.Type = oPage.Type
	oPageAdded.Status = oPage.Status
	oPageAdded.ImageName = snPage
	iDiv = InStrRev(snPage, ".")
	sDataFile = Left(snPage, iDiv) & "xml"
	oPageAdded.Variable("DATAFILE")=sDataFile
	
	'copy all Variables
	nNumOfVars = oPage.NumOfVars	
	For nIndex = 0 to oPage.NumOfVars-1
		sVarName = oPage.GetVariableName(nIndex)
		if sVarName <> "IMAGEFILE" and sVarName <> "DATAFILE" then
			oPageAdded.Variable(sVarName) = oPage.Variable(sVarName)
		End If
	Next 'nIndex
	
	'if (oPage.Variable("PD") <> "") then oPageAdded.Variable("PD") = oPage.Variable("PD")
	'if (oPage.Variable("ScanSrcPath") <> "") then oPageAdded.Variable("ScanSrcPath") = oPage.Variable("ScanSrcPath")
	
	SplitAPage = True
	
	
End Function
		
Function SplitChildBatch(pObj,sBucket,bIndex)
		
	Dim sBatchDir
	Dim sNewNum
	Dim sPageFile
	Dim PageFileName
	Dim oSplitDCO
	Dim oPage
	Dim oField
	Dim oDocAdded
	Dim oFieldAdded
	Dim oDoc
	Dim nIndex1
	Dim nIndex2
	Dim sPageID
	Dim sBatchPath
  
	'
	' SplitChildBatch
	' called internally to perform the splitting after evaluating the buckets required
	' called once for each splitting value
	' moves all pages/docs with that splitting value into a new child batch
	' parameters: batch object (pObj), splitting value
	'
	SplitChildBatch = False
	
	sBatchPath = Pilot.BatchDir	' parent batch directory name
	
	If IsObject(oDCBase36) then
		'oDCBase36.Base10Number=bIndex+1
		sNewNum = Right("000"& CStr(oDCBase36.LongToAlphaDecimal(bIndex+1)), 2) ' allow up to 1295 subbatches
	Else
		sNewNum = Right("000" & CStr(bIndex+1), 2)	' allow up to 99 subbatches
	End if
    
	sBatchPath = sBatchPath & "." & sNewNum
	sBatchDir = sBatchPath	' now both contain the new batchdir path, with no trailing \
	
	On Error Resume Next
  Err.Clear
	FileMgr.CreateFolder(sBatchPath)
    
  If Err.Number > 0 Then
    WriteLog("ERROR: child batch folder " & sBatchBath & " already exists or cannot be created.  SplitBatch can only be called once on a parent batch.")
		Call Writelog("Error details: " & Err.Description)
    Call AbortBatch()
		Set oSplitDCO = Nothing
		Exit Function
  End If
  
	On Error Goto 0
	If ErrorHandler("CreateFolder") Then
		Set oSplitDCO = Nothing
		Exit Function
	End If
	
	sPageFile = "bsplit" & CStr(sNewNum) & ".XML"
	PageFileName = sBatchPath + "\" + sPageFile
	
	Pilot.ChildCondition(bIndex) = 0	' first condition
	WriteLog("Child # " & CStr(bIndex) & " raising condition 0")
	Pilot.ChildPageFile(bIndex) = PageFileName
	Pilot.ChildImageDir(bIndex) = sBatchDir

	Set oSplitDCO = CreateObject("tDCO.Batch")
	oSplitDCO.ID = CStr(pObj.ID) & "." & sNewNum	' BatchID = BBBBB.N or .NN
	oSplitDCO.Type = CStr(pObj.Type)
	oSplitDCO.Variable("ParentBatch") = CStr(pObj.ID)
	oSplitDCO.Variable("ParentBatchDir") = Pilot.BatchDir
	
	'copy all Batch Variables from the parent batch
	nNumOfVars = pObj.NumOfVars	
	For nIndex = 0 to pObj.NumOfVars-1
		sVarName = pObj.GetVariableName(nIndex)
		if sVarName <> "ED" and sVarName <> "AD" and sVarName <> "EP" and sVarName <> "AP" then
			oSplitDCO.Variable(sVarName) = pObj.Variable(sVarName)
		End If
	Next 'nIndex
	
	' copy any/all Fields from parent batch node
	For nIndex1 = 0 to pObj.NumOfChildren-1		' go through all nodes in Batch, copying batch-level fields only
		Set oField = pObj.GetChild(nIndex1)
		If oField.ObjectType = DCO_FIELD Then
			Set oFieldAdded = oSplitDCO.AddChild(DCO_FIELD, oField.ID, -1)
			' copy all Field variables
			nNumOfVars = oField.NumOfVars	
			For nIndex = 0 to oField.NumOfVars-1
				sVarName = oField.GetVariableName(nIndex)
				oFieldAdded.Variable(sVarName) = oField.Variable(sVarName)
			Next 'nIndex
		Call RRCopyChars(oField,oFieldAdded,1,LEN(oField.Text)) ' copy field's text to child batch
		End If
	Next
		
	For nIndex1 = 0 To pObj.NumofChildren-1		' go through all nodes in Batch (expecting pages and/or docs)
			
		Set oPage = pObj.GetChild(nIndex1)
		Set oSaveCurrentObj = CurrentObj
		Set CurrentObj = oPage
		If IsAlive(g_DCSmart) then g_DCSmart.SetRRCurrentDCO(CurrentObj)
		if sBucketName = "" then ' for testing - when no parameter just use pageID
			sBucketValue = oPage.ID
		else
			sBucketValue = CStr(MetaWord(sBucketName))
		End if
		Set CurrentObj = oSaveCurrentObj
		If IsAlive(g_DCSmart) then g_DCSmart.SetRRCurrentDCO(CurrentObj)
		
		If sBucketValue = sBucket Then		' we have a page or doc to be split out
		
			' value of page/doc matches dict key for this subbatch
		
			WriteLog("Page/Doc " & CStr(nIndex1+1) & " " & sBucketValue & " = " & sBucket & ", add to child batch " & CStr(sNewNum))
		
			if oPage.ObjectType = DCO_DOCUMENT Then		' SPLIT DOCUMENT
				Set oDoc = oPage		
				' Update DocIDs with the newly split batchID, but keep original doc number in last position
				iDiv = InStrRev(oDoc.ID, ".")
				if iDiv > 0 then
					sPageID = oSplitDCO.ID & Mid(oDoc.ID, iDiv)
				else
					sPageID = oDoc.ID	' old DocID
				End If
				WriteLog("Insert DOC ID " & sPageID)
				Set oDocAdded = oSplitDCO.AddChild(DCO_DOCUMENT, sPageID, -1)
				oDocAdded.Type = oDoc.Type
				oDocAdded.Status = oDoc.Status
				'copy all Doc Variables
				nNumOfVars = oDoc.NumOfVars	
				For nIndex = 0 to oDoc.NumOfVars-1
					sVarName = oDoc.GetVariableName(nIndex)
					oDocAdded.Variable(sVarName) = oDoc.Variable(sVarName)
				Next 'nIndex
				' need to add all pages in this doc now
				for nIndex2 = 0 to oDoc.NumofChildren-1
					set oPage = oDoc.GetChild(nIndex2)
					If Not IsObject(oPage) Or oPage Is Nothing Then
						WriteLog( "Error on page/doc " & Cstr(nIndex1))
						Set oSplitDCO = Nothing
						Exit Function
					End If
					ret = SplitAPage(oPage, oDocAdded, sBatchPath)
					if ret = False Then
						WriteLog( "Error on SplitAPage " & Cstr(nIndex2) & " from Doc " & CStr(nIndex1))
						Set oSplitDCO = Nothing
						Exit Function
					End If
				next 	' nIndex2 (doc in batch)
			Else 
				if oPage.ObjectType = DCO_PAGE	Then	' Not a document, maybe an ubbound page to split
					ret = SplitAPage(oPage, oSplitDCO, sBatchPath)
					if ret = False Then
						WriteLog( "Error on SplitAPage " & Cstr(nIndex1))
						Set oSplitDCO = Nothing
						Exit Function
					End If
				End If
			End If								' END OF SPLIT PAGE OR DOC
		Else							' value of page/doc does not match dict key for this subbatch
			WriteLog("Page/Doc " & CStr(nIndex1+1) & " " & sBucketValue & " <> " & sBucket)
		End If						' END OF BUCKET MATCH / SPLIT
	Next

	WriteLog( "Writing " & PageFileName)
	SplitChildBatch = oSplitDCO.Write(PageFileName)
	if SplitChildBatch <> True then
		WriteLog ("Failed - error: " & oSplitDCO.GetLastError)
	End If
	
	Set oSplitDCO = Nothing


End Function
		
Function SplitTest(bInter, bDebug, StrParam) 	
  ' Batch level only.
	Pilot.ChildrenQuantity = 1
	Pilot.ChildCondition(0) = 0	' first condition
	Pilot.ChildPageFile(0) = "aa"
	Pilot.ChildImageDir(0) = "bb"
	Pilot.ChildrenQuantity = 3
	'Pilot.ChildCondition(0) = 0	' first condition
	'Pilot.ChildCondition(1) = 0	' first condition
	'Pilot.ChildCondition(2) = 0	' first condition
	Pilot.ChildCondition(1) = 0	' first condition
	Pilot.ChildPageFile(1) = "aa"
	Pilot.ChildImageDir(1) = "bb"
	Pilot.ChildCondition(2) = 0	' first condition
	Pilot.ChildPageFile(2) = "aa"
	Pilot.ChildImageDir(2) = "bb"
	SplitTest = True
	WriteLog("SplitTest")

End Function

Function SplitBatch(bInter, bDebug, StrParam) 	

  'Splits documents or pages in the batch into sub-batches, according to the value of the smart parameter you enter.
  ' If a page is part of a document, it goes along with all other pages in that parent document. For more information, 
  ' see the Parameters and Details sections below. "
  
   'A <b>smart parameter</b> that determines the sub-batch for each document or page.<br/><br/>
   ' <b>Important:</b> The action evaluates each document and loose page in the batch. 
   ' An unbound page is any page not inside a document.  
   ' The set of smart parameter values found during the evaluation are grouped into "buckets":<br/><br/>
   ' 1. Identical values go into the same bucket.<br/><br/>
   ' 2. If there are multiple buckets, all pages/documents that share the same value will 
   ' split to the same child batch.<br/><br/>
   ' 3. There can be only <i>one child batch</i> for <i>each unique bucket value.</i><br/><br/>
   ' 
   ' Child batches are named like the parent batch, but with a suffix such as .01, .02, etc.<br/><br/>
   ' For example you might use for splitting:<br/><br/>  
   ' <b>@D.Inbox.</b> If there is an Inbox variable in each document, this will split documents by 
   ' the value of the Inbox. Important! Any document or loose page 
   ' that does not have this value set will remain in the parent batch.
 	
	On Error Resume Next
	
	Dim nPages
	Dim CurrentPage
	Dim retn
	Dim retSplit
	Dim sBucketValue
	Dim oPage
	Dim i
	Dim nIndex
	Dim bReturn
	
	Pilot.ChildrenQuantity = 0
	sBucketName = StrParam
	
	SplitBatch = False
	retSplit = True
	
	If CurrentObj.ObjectType <> DCO_BATCH Then 
		Writelog("SplitBatch action must be bound at the batch level. Failed.")
		Exit Function
	End If
	
	'Force write DCO Data files
  If Instr(lcase(Pilot.dcofile),lcase(Pilot.BatchDir))<=0 Then
    sPageFile = Pilot.BatchDir + "\" + Pilot.dcofile
  Else
    sPageFile = Pilot.dcofile
	End if
  
  bReturn=DCO.Write(sPageFile)
	If bReturn=False then 
		Call Writelog("ERROR Writing File: '" & Pilot.dcofile & "'. Aborting Batch.")
		Call Writelog("DCO Last Error:'" & DCO.GetLastError() & "'.")
    Call AbortBatch()
	End if
	
	WriteLog("SplitBatch on value: '" & StrParam & "'")
	
	sStatID = dco.Variable("ScanStation")
	sScanUser = dco.Variable("ScanUser")
	
	On Error Goto 0
	
	nPages = CurrentObj.NumOfChildren()
	Call WriteLog("SplitBatch processing " + CStr(CurrentObj.NumOfChildren())+" pages or docs")
	
	If nPages = 0 Then
		' abort the batch
		Exit Function
	End If
	
	Set dictBuckets = CreateObject("Scripting.Dictionary")
	
 	For CurrentPage = 0 To nPages - 1

	'		Call WriteLog("SplitBatch evaluate # " + CStr(CurrentPage+1))
		Set oPage = CurrentObj.GetChild(CurrentPage)
		
		If oPage.ObjectType = DCO_PAGE or oPage.ObjectType = DCO_DOCUMENT Then

			If sBucketName = "" then ' for testing - when no parameter just use pageID
				sBucketValue = oPage.ID
				Else
					On Error Resume Next
					Set oSaveCurrentObj = CurrentObj
					Set CurrentObj = oPage
					If IsAlive(g_DCSmart) then g_DCSmart.SetRRCurrentDCO(CurrentObj)
					sBucketValue = CStr(MetaWord(sBucketName))
					Call WriteLog("Page or document value: " & sBucketValue)
					Set CurrentObj = oSaveCurrentObj
					If IsAlive(g_DCSmart) then g_DCSmart.SetRRCurrentDCO(CurrentObj)
					On Error Goto 0
				End if
				if sBucketValue <> "" then
					if Not dictBuckets.Exists(sBucketValue) then
							dictBuckets.Add sBucketValue, sBucketValue
				End If
			End If
		Else
			'Call WriteLog("Process unknown object - failed")	
			'Set dictBuckets = Nothing
			'bAbort = True
			'nTaskStatus = RetAbort
			'Exit Function
		End If
	Next	' next page in batch

	' Was maximum of 99 sub-batches now with new object 'oDCBase36' and AlphaDecimal names (01 to ZZ) allows 1295 sub-batches
	if dictBuckets.Count > 1295 Then
			WriteLog("More than 1295 values in " & sBucketName & ", SplitBatch failed")
	   	Set dictBuckets = Nothing
			bAbort = True
      nTaskStatus = RetAbort
			Exit Function
	End If
	
	If dictBuckets.Count > 0 Then
		' we will split N batches
		Pilot.ChildrenQuantity = dictBuckets.Count	' this must be done before setting any of the conditions 
		aBuckets = dictBuckets.Keys
		For i = 0 to dictBuckets.Count-1
			WriteLog ("SplitBatch process subbatch " & CStr(i) & " " & aBuckets(i))
			retSplit = SplitChildBatch(CurrentObj, aBuckets(i), i) ' split a subbatch for each bucket
			if retSplit <> True then 
				bAbort = True
	      nTaskStatus = RetAbort
				Exit For
			End If
		Next ' next i
		
		' clear out all pages/docs that were split from the page file
		For nIndex = CurrentObj.NumOfChildren-1 to 0 Step -1
			Set oPage = CurrentObj.GetChild(nIndex)
			if sBucketName = "" then ' for testing - when no parameter just use pageID
				sBucketValue = oPage.ID
			else
				On Error Resume Next
				Set oSaveCurrentObj = CurrentObj
				Set CurrentObj = oPage
				If IsAlive(g_DCSmart) then g_DCSmart.SetRRCurrentDCO(CurrentObj)
				sBucketValue = CStr(MetaWord(sBucketName))
				Call WriteLog("Page or document value: " & sBucketValue)
				Set CurrentObj = oSaveCurrentObj
				If IsAlive(g_DCSmart) then g_DCSmart.SetRRCurrentDCO(CurrentObj)
				On Error Goto 0
			End if
			if sBucketValue <> "" then  ' delete any page or doc that has a bucket value - e.g. is split
				CurrentObj.Deletechild(nIndex)
		  End If
		Next 'nIndex
	End If


	Set dictBuckets = Nothing		
	
	If retSplit = True Then
		SplitBatch = True
	End If	
			

End Function
